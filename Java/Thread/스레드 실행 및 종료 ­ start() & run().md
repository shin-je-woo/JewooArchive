# Previous

- 자바 스레드는 OS 스케줄러에 의해 실행 순서가 결정되며, 스레드 실행 시점을 JVM 에서 제어할 수 없다.
- 새로운 스레드는 현재 스레드와 독립적으로 실행되고, 최대 한번 시작할 수 있으며, 스레드가 종료된 후에는 다시 시작 할 수 없다.

# 💡 스레드 실행

## start()

- 스레드를 실행시키는 메서드로 시스템 콜을 통해서 커널에 커널 스레드 생성을 요청한다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/6fdf7ddd-f982-4060-aa43-00b20e057a07)

## run()

- 스레드가 실행이 되면 해당 스레드에 의해 자동으로 호출되는 메서드이다.
- Thread 의 run() 이 자동 호출되고 여기서 Runnable 구현체가 존재할 경우 Runnable 의 run() 을 실행하게 된다.
- public static void main(String[] args) 메서드가 메인 스레드에 의해 자동으로 호출되는 것과 비슷한 원리이다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/5a1d135f-0e4a-43fe-a8b8-670c1d89e0ff)

- ❗ 주의 할 것은 만약 start() 가 아닌 run() 메서드를 직접 호출하면 새로운 스레드가 생성되지 않고 직접 호출한 스레드의 실행 스택에서 run() 이 실행될 뿐이다 .

![image](https://github.com/shin-je-woo/TIL/assets/39439576/1d2683f9-b085-4e4f-bc61-b241a1b377da)

# 💡 스레드 스택(Stack)

- 스레드가 생성되면 해당 스레드를 위한 스택(stack)이 만들어진다.
- 스택은 각 스레드마다 독립적으로 할당되기 때문에 스레드 간 접근하거나 공유할 수 없고 이는 스레드로부터 안전하다 할 수 있다.
- 스택은 OS 에 따라 크기가 주어지고 주어진 크기를 넘기게 되면 java.lang.StackOverFlowError 가 발생하게 된다.

## 스택의 구성정보

- 스택에 대한 메모리 접근은 Push & Pop 에 의한 후입선출 (LIFO : Last In First Out) 순서로 이루어지며 스택은 프레임(Frame) 으로 구성되어 있다.
- 프레임은 새 메서드를 호출할 때마다 로컬 변수(지역변수, 파라미터) 및 객체 참조 변수와 함께 스택의 맨 위에 생성(push)된다.
- 메서드 실행이 완료되면 해당 스택 프레임이 제거(pop)되고 흐름이 호출한 메서드로 돌아간다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/8d74e0f3-5276-4161-8161-46fa0b0ee297)

## 스택 메모리 상태 관리

- 스택 내부의 변수는 변수를 생성한 메서드가 실행되는 동안에만 존재한다.
- 스택 메모리에 대한 액세스는 Heap 메모리와 비교할 때 빠르다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/33c69c65-da4b-4f05-a15e-fdacce15a336)

# 💡 스레드 종료

- 스레드는 run() 메서드의 코드가 모두 실행되면 자동으로 종료된다.
- 스레드는 예외가 발생할 경우 종료되며 다른 스레드에 영향을 미치지 않는다.
- 어플리케이션은 싱글스레드인 경우와 멀티스레드인 경우 종료 기준이 다르다.

## 싱글스레드 어플리케이션

- 싱글스레드 어플리케이션은 사용자 스레드(user thread) 가 없는 기본 main thread 만 있는 상태이다.
- main thread 만 종료되면 어플리케이션이 종료된다.

## 멀티스레드 어플리케이션

- 멀티스레드 인 경우 JVM 에서 실행하고 있는 모든 스레드가 종료되어야 어플리케이션이 종료된다.
- 동일한 코드를 실행하는 각 스레드의 종료 시점은 처리 시간 및 OS 의 스케줄링에 의해 결정되므로 매번 다르게 나올 수 있다.
