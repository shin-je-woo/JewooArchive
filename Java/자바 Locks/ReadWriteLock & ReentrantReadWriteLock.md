# Previous

- ReadWriteLock 은 읽기 작업과 쓰기 작업을 위해 연관된 두 개의 락(읽기 락, 쓰기 락)을 유지하는 인터페이스이다.
- 일반적으로 락은 데이터를 조작하는 하나의 스레드의 임계영역을 보호하는 장치이며 데이터를 읽는 작업만 실행되는 영역은 여러 스레드가 동시에 접근해도 동시성 문제가 발생하지 않는다.
- 읽기 작업이 많고 쓰기 작업이 적은 영역을 효율적으로 처리하기 위해 다수의 읽기와 하나의 쓰기를 읽기락과 쓰기락으로 구분해서 락을 운용하는 것이 필요하다.

# 💡 특징

### 성능 개선
- 읽기 락과 쓰기 락의 조합은 상호 배타적인 락을 사용하는 것보다 데이터에 대한 동시 액세스를 허용하므로 동시성이 높아진다.
- 특히 읽기 작업이 더 빈번한 경우에 효과적이며 읽기 락의 경우 여러 스레드가 동시에 데이터를 읽을 수 있고 쓰기 락의 경우 하나의 스레드만 데이터를 수정할 수 있다.

### 메모리 동기화
- 읽기 락 작업은 다른 읽기 락 작업과 상호 작용하는 것이 아니므로 스레드 간 동시에 읽기 작업을 하더라도 메모리의 가시성에 아무런 문제가 없다.
- 쓰기 락 작업은 읽기 작업 및 다른 쓰기 작업과의 메모리 동기화를 보장해야 한다. 즉 스레드가 쓰기 락을 해제하고 다른 스레드가 읽기 락을 얻었을 때 이전 쓰기 작업의 업데이트를 볼 수 있어야 한다. (가시성)

### 사용 기준
- 읽기/쓰기 락의 사용은 데이터가 읽히는 빈도와 수정되는 빈도, 읽기 및 쓰기 작업의 지속 시간, 데이터에 대한 경합(동시에 데이터를 읽거나 쓰려는 스레드 수)에 따라 결정된다.
- 수정은 드물게 일어나고 검색은 빈번히 발생한다면 읽기/쓰기 락의 사용에 적합한 이상적인 후보라 할 수 있지만 업데이트가 빈번해지면 데이터가 대부분 배타적으로 작동한다.
- 읽기 작업 시간이 긴 경우 여러 스레드들이 경합없이 모두 읽는 이점이 있으나 너무 짧은 경우 읽기/쓰기 락 구현의 오버헤드(읽기작업과 쓰기 작업의 상태를 계속 확인하기 때문에 상호 배제 락보다 알고리즘이 더 복잡함)가 증가하기 때문에 효율성이 떨어진다.

# 💡 ReadLock & WriteLock

### ReentrantReadWriteLock.ReadLock

- 여러 읽기 스레드가 동시에 읽기 락을 얻을 수 있으며 읽기 락이 보유되는 동안에는 다른 읽기 스레드들도 읽기 락을 얻을 수 있다.
- 쓰기 락은 읽기 락이 보유되는 동안에 얻을 수 없다. 그러나 대기하는 중에도 계속 읽기락을 요청하는 상황이 발생하면 쓰기락을 요청한 스레드는 기아상태가 될 수 있으므로 쓰기락을 요청한 상태에서는 더 이상 스레드가 읽기 접근을 할 수 없다.
- 가장 큰 장점은 여러 스레드가 상호배제 없이 동시에 데이터를 읽을 수 있어서 동시성이 증가한다는 점이다.

### ReentrantReadWriteLock.WriteLock

- 쓰기 락은 배타적이며 한 번에 하나의 스레드만 쓰기 락을 보유할 수 있고 쓰기 락을 보유하는 동안에는 다른 어떤 스레드도 읽기 락이나 쓰기 락을 얻을 수 없다.
- 쓰기 락이 보유되는 동안에 데이터를 수정하는 작업이 수행되며 이 작업이 완료될 때까지 다른 스레드가 해당 락을 얻지 못한다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/a0e512af-dcc5-4caf-a688-fc07cfd1a625)

# 💡 ReadWriteLock 구조

![image](https://github.com/shin-je-woo/TIL/assets/39439576/df946e40-e7b4-4793-a1bb-cfa507d29b76)

# 💡 ReentrantReadWriteLock 기본 구현

![image](https://github.com/shin-je-woo/TIL/assets/39439576/661b7ac3-0344-4be7-b1db-cfa8c4f30d56)

# 💡 ReentrantReadWriteLock 재 진입 정책

- 이 락은 ReentrantLock 과 같이 읽기 및 쓰기 락을 다시 획득할 수 있도록 재 진입을 허용하며 쓰기 락을 보유하고 있는 스레드가 모든 쓰기 락을 해제하기 전까지는 재진입이 아닌 (Non-reentrant) 읽기 스레드를 허용하지 않는다.
- 쓰기 스레드는 읽기 락을 획득할 수 있지만 읽기 스레드가 쓰기 락을 획득하려고 하면 실패하게 된다.
- 쓰기 락을 보유한 스레드가 읽기 락 아래에서 읽기를 수행하는 메서드 또는 콜백 호출 시 재 진입이 유용할 수 있다.

### 락 다운그레이드 (Lock Downgrade)

- 재 진입성은 쓰기 락에서 읽기 락으로 다운그레이드할 수 있게 해 준다.
- 이를 위해 쓰기 락을 획득한 후 읽기 락을 획득하고 마지막으로 쓰기 락을 해제한다.

### 락 업그레이드 (Lock Upgrade)
- 읽기 락에서 쓰기 락으로 업그레이드하는 것은 불가능하다.
- 읽기 락은 여러 스레드가 동시에 보유할 수 있기 때문에 업그레이드가 허용되지 않는다.

***쓰기 락을 획득하면 다른 스레드는 어떤 형태로든 락을 획득할 수 없지만 읽기 락을 사용하면 원하는 경우 다른 모든 스레드가 읽기 락을 획득할 수 있게 한다.   
여기서 락을 Downgrade 한다는 것은 쓰기 락을 보유한 상태에서 읽기 락을 획득한 다음 쓰기 락을 해제하여 읽기 락만 유지하도록 전환 할 수 있음을 의미한다.   
예를 들어 매우 중요한 작업은 쓰기 락으로 시작해서 상호배제를 구현하고 중요 작업을 마친 후에는 동시적인 읽기 접근을 허용하는 읽기 락 스레드를 가질 수 있다.***

```java
public static void main(String[] args) {
    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();
    ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

    // 획득한 쓰기 락을 다운그레이드하기 위해 읽기 락을 획득
    writeLock.lock();
    System.out.println("Write lock acquired");

    // 다운그레이드: 쓰기 락을 읽기 락으로 다운그레이드
    readLock.lock();
    System.out.println("Read lock acquired (downgraded from write lock) ");

    // 쓰기 락 해제
    writeLock.unlock();

    // 읽기 락 사용 , 여기서부터는 상호배제가 아님
    getList(sharedData);

    // 읽기 락 해제
    readLock.unlock();
}
```
