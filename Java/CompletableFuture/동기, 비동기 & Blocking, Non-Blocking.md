# Previous

- 동기/비동기는 요청한 작업에 대해 완료 여부를 신경 써서 작업을 순차적으로 수행할지 아닌지에 대한 관점이다.
- 블로킹/논블록킹은 단어 그대로 현재 작업이 block(차단, 대기) 되느냐 아니냐에 따라 다른 작업을 수행할 수 있는지에 대한 관점이다.

# 💡 동기/비동기

### 동기

- 동기(Synchronous)는 작업이 순차적으로 실행되며 한 작업의 시작과 완료가 다음 작업의 시작과 완료와 밀접하게 연결된 방식을 의미한다.
- 하나의 작업이 실행 중인 동안 다른 작업은 대기해야 하며 작업의 결과를 기다린 후에 다음 작업이 진행된다.
- 작업은 한번에 하나씩 진행해야 하며 작업을 건너 뛰거나 빠뜨릴 수 없다.

### 비동기

- 비동기(Asynchronous) 는 작업이 순차적으로 실행되지 않으며 각 작업이 다른 작업의 완료를 기다리지 않고 독립적으로 실행되는 방식을 의미한다.
- 한 작업이 시작된 후에도 다음 작업이 바로 시작될 수 있으며 작업의 결과에 관심이 없고 기다리지 않으며 다른 작업을 실행할 수 있다.
- 비동기 작업은 주로 I/O 작업과 같이 시간이 오래 걸리는 작업을 다룰 때 유용하며 다수의 작업을 동시에 처리하거나 빠른 응답 시간을 보장해야 하는 경우에 활용된다.
- " Fire and Forget " 이라는 용어가 있는데 이는 비동기 프로그래밍 용어로서 작업을 시작하고 그 결과에 대해 더 이상 관심을 갖지 않고 진행하는 것을 의미한다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/0e670727-d4f5-4909-9ec9-5ac0b954b28d)

## 비동기의 성능 이점

- 보통 비동기 특징을 이용하여 성능과 연관지어 말한다.
- I/O 작업과 같은 느린 작업이 발생할 때, 기다리지 않고 다른 작업을 처리하면서 동시에 처리하여 멀티 작업을 진행할수 있기 때문이다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/701a4b26-c5db-4dba-969e-20721d12e343)

- 예를 들어, 웹 애플리케이션에서 데이터베이스 쿼리를 수행하는 작업이 있다고 가정해보자.
- 이 작업을 만일 동기적으로 수행하면, 데이터베이스에서 응답이 올 때까지 기다려야 한다.
- 그러면 이 때 웹 애플리케이션은 다른 요청을 처리하지 못하므로, 대규모 트래픽이 발생할 경우 웹 애플리케이션의 성능이 저하될 수 있다.
- 하지만 비동기 방식으로 데이터베이스 쿼리를 수행하면, 데이터베이스에서 응답이 올 때까지 기다리는 동안에도 다른 요청을 '동시에 처리'할 수 있게 된다.
- 이렇게 비동기 방식을 사용하면, 대규모 트래픽에서도 안정적으로 동작할 수 있는 웹 애플리케이션을 만들 수 있다.
- 여기서 '동시 처리' 라는 개념은 두 개 이상의 작업이 동시에 실행되는 것을 의미 한다. 이는 멀티 스레드와 같은 방식으로 구현될 수 있다.

## 함수 관점에서의 동기/비동기

- 함수를 호출한자(Caller)와 호출된 함수를 수행하는 주체(Callee)가 동일 스레드이면 동기, 서로 다른 스레드이면 비동기 관계가 형성 된다고 할 수 있다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/39d01420-b42f-48ce-bbaa-7f4271b12b50)

- 함수를 호출한자(Caller)가 호출된 함수의 작업 결과에 대해 관심을 가지고 있으면 동기, 없으면 비동기라 할 수 있다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/141e39ba-2f68-4411-a662-9dc3518d9d3b)


- 정리하자면 작업 3개를 요청했는데 응답에서 그 순서가 지켜진다면 동기이고 어떤 게 먼저 올지 모른다면 비동기라고 보면 된다.

# 💡 Blocking / Non-Blocking

- 블로킹과 논블록킹은 단어에서 알 수 있듯이 다른 요청의 작업을 처리하기 위해 현재 작업을 block(차단, 대기) 하냐 안하냐의 유무를 나타내는 프로세스의 실행 방식이다.
- 동기/비동기가 전체적인 작업에 대한 순차적인 흐름 유무라면, 블로킹/논블로킹은 전체적인 작업의 흐름 자체를 막냐 안 막냐로 볼 수 있는 것이다.
- 예를 들어, 파일을 읽는 작업이 있을 때, 블로킹 방식으로 읽으면 파일을 다 읽을 때까지 대기하고, 논블로킹 방식으로 읽으면 파일을 다 읽지 않아도 다른 작업을 할 수 있다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/29a51e2d-d771-4e1e-a80f-852c69483865)

### Blocking

- 블록킹(Blocking)은 주로 동기 작업에서 나타나는 현상으로 작업이 완료될 때까지 실행 흐름을 멈추고 대기하는 상태를 의미한다.
- 파일을 읽거나 네트워크에서 데이터를 받아오는 I/O 작업이 블록킹 작업에 해당하는데 해당 작업이 완료될 때까지 다른 작업은 차단되고 대기 상태에 놓이게 된다.
- 블록킹 작업은 주로 작업이 완료될 때까지 결과를 기다려야 하는 경우에 사용되며 대부분 동기적인 처리에서 나타난다.

### Non-Blocking

- 넌블록킹(Non Blocking)은 주로 비동기 작업에서 나타나는 현상으로 블록킹(Block)되지 않고 실행 흐름이 지속되는 특성을 나타낸다.
- 특정 작업이 진행 중일 때에도 다른 작업이 계속 실행되며, 작업이 완료되지 않았더라도 대기하지 않고 다음 작업을 처리하는 방식을 의미한다.
- Non Blocking 작업은 다른 작업들과 동시에 진행될 수 있어서 전체 시스템의 응답성을 향상시킬 수 있다.

## 함수 관점에서 Blocking & Non Blocking

- 함수를 호출한자(Caller)와 호출된 함수를 수행하는 주체(Callee)가 동일 스레드이면 Blocking, 서로 다른 스레드이면 Non Blocking 이 발생 한다고 볼 수 있다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/2af1acfd-2b8e-4ef1-8d1b-24bd51439c48)

- 함수를 호출한자(Caller)와 호출된 함수를 수행하는 주체(Callee)가 순차적으로 작업을 진행하면 Blocking, 동시적으로 진행하면 Non Blocking 이라 할 수 있다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/84862b84-852e-48f2-860f-ae431406bb00)


