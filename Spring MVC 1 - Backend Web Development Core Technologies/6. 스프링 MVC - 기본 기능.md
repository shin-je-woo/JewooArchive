# 요청 매핑
### PathVariable(경로 변수) 사용
```java
/**
 * PathVariable 사용
 * 변수명이 같으면 생략 가능
 * @PathVariable("userId") String userId -> @PathVariable userId
 */
@GetMapping("/mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data) {
    log.info("mappingPath userId={}", data);
    return "ok";
}
```
* 요청: http://localhost:8080/mapping/userA
* 최근 HTTP API는 다음과 같이 리소스 경로에 식별자를 넣는 스타일을 선호한다.
  * /mapping/userA
  * /users/1

### 미디어 타입 조건 매핑 - HTTP 요청 Content-Type, consume
```java
/**
 * Content-Type 헤더 기반 추가 매핑 Media Type
 * consumes="application/json"
 * consumes="!application/json"
 * consumes="application/*"
 * consumes="*\/*"
 * MediaType.APPLICATION_JSON_VALUE
 */
@PostMapping(value = "/mapping-consume", consumes = "application/json")
public String mappingConsumes() {
    log.info("mappingConsumes");
    return "ok";
}
```
* HTTP요청메시지의 Content-Type 헤더가 consumes에 지정한 미디어 타입과 일치할 때 매핑한다.
* 만약 미디어 타입이 일치하지 않으면 HTTP 415 상태코드(Unsupported Media Type)을 반환한다.

### 미디어 타입 조건 매핑 - HTTP 요청 Accept, produce
```java
/**
 * Accept 헤더 기반 Media Type
 * produces = "text/html"
 * produces = "!text/html"
 * produces = "text/*"
 * produces = "*\/*"
 */
@PostMapping(value = "/mapping-produce", produces = "text/html")
public String mappingProduces() {
    log.info("mappingProduces");
    return "ok";
}
```
* HTTP요청메시지의 Accept 헤더가 produces 지정한 미디어 타입과 일치할 때 매핑한다.
* 만약 미디어 타입이 일치하지 않으면 HTTP 406 상태코드(Not Acceptable)을 반환한다.

# HTTP 요청 - 기본, 헤더 조회
애노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다.
HTTP 헤더 정보를 조회하는 방법을 알아보자.
```java
@RestController
public class RequestHeaderController {
    @RequestMapping("/headers")
    public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,
                          Locale locale,
                          @RequestHeader MultiValueMap<String, String> headerMap,
                          @RequestHeader("host") String host,
                          @CookieValue(value = "myCookie", required = false) String cookie
    ) {
        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("header host={}", host);
        log.info("myCookie={}", cookie);
        return "ok";
    }
}
```
* HttpMethod : HTTP 메서드를 조회한다. org.springframework.http.HttpMethod
* Locale : Locale 정보를 조회한다.
* @RequestHeader MultiValueMap<String, String> headerMap
    * 모든 HTTP 헤더를 MultiValueMap 형식으로 조회한다.
* @RequestHeader("host") String host
  * 특정 HTTP 헤더를 조회한다.
  * 속성
    * 필수 값 여부: required
    * 기본 값 속성: defaultValue
* @CookieValue(value = "myCookie", required = false) String cookie
  * 특정 쿠키를 조회한다.
  * 속성
    * 필수 값 여부: required
    * 기본 값: defaultValue
> 참고
> MultiValueMap  
> MAP과 유사한데, 하나의 키에 여러 값을 받을 수 있다.  
> HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다. 

# HTTP 요청 파라미터 - @RequestParam
* 스프링이 제공하는 @RequestParam 을 사용하면 요청 파라미터를 매우 편리하게 사용할 수 있다.
* @RequestParam은 required, defaultValue 등 다양한 속성을 지정할 수 있다.
```java
@RequestMapping("/request-param-default")
public String requestParamDefault(
@RequestParam(required = true, defaultValue = "guest") String username,
@RequestParam(required = false, defaultValue = "-1") int age) {
    log.info("username={}, age={}", username, age);
    return "ok";
}
```
### 파라미터를 Map으로 조회하기 - requestParamMap
```java
/**
 * @RequestParam Map, MultiValueMap
 * Map(key=value)
 * MultiValueMap(key=[value1, value2, ...]) ex) (key=userIds, value=[id1, id2])
 */
@ResponseBody
@RequestMapping("/request-param-map")
public String requestParamMap(@RequestParam Map<String, Object> paramMap) {
    log.info("username={}, age={}", paramMap.get("username"),
    paramMap.get("age"));
    return "ok";
}
```
* 파라미터를 Map, MultiValueMap으로 조회할 수 있다.
* 파라미터의 값이 1개가 확실하다면 Map 을 사용해도 되지만, 그렇지 않다면 MultiValueMap 을 사용하자.

# HTTP 요청 파라미터 - @ModelAttribute
```java
/**
 * @ModelAttribute 사용
 * 참고: model.addAttribute(helloData) 코드도 함께 자동 적용됨, 뒤에 model을 설명할 때 자세히 설명
 */
@ResponseBody
@RequestMapping("/model-attribute-v1")
public String modelAttributeV1(@ModelAttribute HelloData helloData) {
    log.info("username={}, age={}", helloData.getUsername(),
    helloData.getAge());
    return "ok";
}
```
* @ModelAttribute는 요청 파라미터를 객체에 바인딩해준다.
* 스프링MVC는 @ModelAttribute 가 있으면 다음을 실행한다.
  * HelloData 객체를 생성한다.
  * 요청 파라미터의 이름으로 HelloData 객체의 프로퍼티를 찾는다. 그리고 해당 프로퍼티의 setter를 호출해서 파라미터의 값을 입력(바인딩) 한다.
    * 예) 파라미터 이름이 username 이면 setUsername() 메서드를 찾아서 호출하면서 값을 입력한다.

# HTTP 요청 메시지 - 단순 텍스트
요청 파라미터와 다르게 HTTP 메시지 바디를 통해 데이터가 직접 넘어오는 경우는 @RequestParam, @ModelAttribute 를 사용할 수 없다.
### HttpEntity
```java
/**
 * HttpEntity: HTTP header, body 정보를 편리하게 조회
 * - 메시지 바디 정보를 직접 조회(@RequestParam X, @ModelAttribute X)
 * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
 *
 * 응답에서도 HttpEntity 사용 가능
 * - 메시지 바디 정보 직접 반환(view 조회X)
 * - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
 */
@PostMapping("/request-body-string-v3")
public HttpEntity<String> requestBodyStringV3(HttpEntity<String> httpEntity) {
    String messageBody = httpEntity.getBody();
    log.info("messageBody={}", messageBody);
    return new HttpEntity<>("ok");
}
```
#### 스프링 MVC는 다음 파라미터를 지원한다.
* HttpEntity: HTTP header, body 정보를 편리하게 조회
  * 메시지 바디 정보를 직접 조회
  * 요청 파라미터를 조회하는 기능과 관계 없음 @RequestParam X, @ModelAttribute X
  * HttpEntity는 응답에도 사용 가능
* 메시지 바디 정보 직접 반환
  * 헤더 정보 포함 가능
  * view 조회X

#### HttpEntity 를 상속받은 다음 객체들도 같은 기능을 제공한다.
* RequestEntity
  * HttpMethod, url 정보가 추가, 요청에서 사용
* ResponseEntity
  * HTTP 상태 코드 설정 가능, 응답에서 사용
  * return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED);

### @RequestBody
@RequestBody 를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다. 참고로 헤더 정보가 필요하다면 HttpEntity 를 사용하거나 @RequestHeader 를 사용하면 된다.
```java
@ResponseBody
@PostMapping("/request-body-string-v4")
public String requestBodyStringV4(@RequestBody String messageBody) {
 log.info("messageBody={}", messageBody);
 return "ok";
}
```
  
#### 요청 파라미터 vs HTTP 메시지 바디
* 요청 파라미터를 조회하는 기능: @RequestParam , @ModelAttribute
* HTTP 메시지 바디를 직접 조회하는 기능: @RequestBody
#### @ResponseBody
* @ResponseBody 를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다.
* 물론 이 경우에도 view를 사용하지 않는다.

# HTTP 요청 메시지 - JSON
### @RequestBody - 문자 변환, 객체 변환
```java
/**
 * @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)
 * HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter (Content-Type: application/json)
 *
 * @ResponseBody 적용
 * - 메시지 바디 정보 직접 반환(view 조회X)
 * - HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter 적용 (Accept: application/json)
 */
@ResponseBody
@PostMapping("/request-body-json-v5")
public HelloData requestBodyJsonV5(@RequestBody HelloData data) {
	log.info("username={}, age={}", data.getUsername(), data.getAge());
	return data;
}
```
* @RequestBody 를 사용하면 HttpMessageConverter가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환해준다.
  
# HTTP 메시지 컨버터 (HttpMessageConverter)
뷰 템플릿으로 HTML을 생성해서 응답하는 것이 아니라, HTTP API처럼 JSON 데이터를 HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리하다.
#### @ResponseBody 를 사용
* HTTP의 BODY에 문자 내용을 직접 반환
* viewResolver 대신에 HttpMessageConverter 가 동작
  * 기본 문자처리: StringHttpMessageConverter
  * 기본 객체처리: MappingJackson2HttpMessageConverter
  * byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음
  
#### 스프링 MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.
* HTTP 요청: @RequestBody , HttpEntity(RequestEntity)
* HTTP 응답: @ResponseBody , HttpEntity(ResponseEntity)

> HttpMessageConverter 인터페이스
```java
public interface HttpMessageConverter<T> {
	boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);
	boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);
	List<MediaType> getSupportedMediaTypes();

	T read(Class<? extends T> clazz, HttpInputMessage inputMessage) 
			throws IOException, HttpMessageNotReadableException;
	void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) 
			throws IOException, HttpMessageNotWritableException;
}
```
#### HTTP 메시지 컨버터는 HTTP 요청, HTTP 응답 둘 다 사용된다.
* canRead() , canWrite() : 메시지 컨버터가 해당 클래스, 미디어타입을 지원하는지 체크
* read() , write() : 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능

#### 주요 메시지 컨버터
#### ByteArrayHttpMessageConverter : byte[] 데이터를 처리한다.
* 클래스 타입: byte[] , 미디어타입: */* ,
* 요청 예) @RequestBody byte[] data
* 응답 예) @ResponseBody return byte[] 쓰기 미디어타입 application/octet-stream
#### StringHttpMessageConverter : String 문자로 데이터를 처리한다.
* 클래스 타입: String , 미디어타입: */*
* 요청 예) @RequestBody String data
* 응답 예) @ResponseBody return "ok" 쓰기 미디어타입 text/plain
#### MappingJackson2HttpMessageConverter : application/json
* 클래스 타입: 객체 또는 HashMap , 미디어타입 application/json 관련
* 요청 예) @RequestBody HelloData data
* 응답 예) @ResponseBody return helloData 쓰기 미디어타입 application/json 관련

# RequestMappingHandlerAdapter 구조
![image](https://user-images.githubusercontent.com/39439576/223338701-a190120e-d12b-42b5-8384-dbf5267272dd.png)
![image](https://user-images.githubusercontent.com/39439576/223338784-04e31350-e44a-4fe2-acfe-0acfe6a618aa.png)

## ArgumentResolver
생각해보면, 애노테이션 기반의 컨트롤러는 매우 다양한 파라미터를 사용할 수 있었다.  
HttpServletRequest , Model 은 물론이고, @RequestParam , @ModelAttribute 같은 애노테이션과  
@RequestBody , HttpEntity 같은 HTTP 메시지를 처리하는 부분까지 매우 큰 유연함을 보여주었다.  
이렇게 파라미터를 유연하게 처리할 수 있는 이유가 바로 ArgumentResolver 덕분이다.

> HandlerMethodArgumentResolver 인터페이스
```java
public interface HandlerMethodArgumentResolver {

    boolean supportsParameter(MethodParameter parameter);

    @Nullable
    Object resolveArgument(MethodParameter parameter, 
						   @Nullable ModelAndViewContainer mavContainer, 
						   NativeWebRequest webRequest, 
						   @Nullable WebDataBinderFactory binderFactory) throws Exception;
}
```
ArgumentResolver 의 supportsParameter() 를 호출해서 해당 파라미터를 지원하는지 체크하고,  
지원하면 resolveArgument() 를 호출해서 실제 객체를 생성한다.  
그리고 이렇게 생성된 객체가 컨트롤러 호출시 넘어가는 것이다.

## ReturnValueHandler
HandlerMethodReturnValueHandler 를 줄여서 ReturnValueHandler 라 부른다.  
ArgumentResolver 와 비슷한데, 이것은 응답 값을 변환하고 처리한다.  
컨트롤러에서 String으로 뷰 이름을 반환해도, 동작하는 이유가 바로 ReturnValueHandler 덕분이다.
> ReturnValueHandler 인터페이스
```java
public interface HandlerMethodReturnValueHandler {
	
    boolean supportsReturnType(MethodParameter returnType);

    void handleReturnValue(Object returnValue, MethodParameter returnType,
                           ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;

}
```

## HttpMessageConverter
![image](https://user-images.githubusercontent.com/39439576/223342060-6a846afc-9f20-4486-9cf2-4262df311dfe.png)
1. 요청의 경우  
@RequestBody 를 처리하는 ArgumentResolver 가 있고, HttpEntity 를 처리하는 ArgumentResolver 가 있다.  
이 ArgumentResolver 들이 HTTP 메시지 컨버터를 사용해서 필요한 객체를 생성하는 것이다.
2. 응답의 경우  
@ResponseBody 와 HttpEntity 를 처리하는 ReturnValueHandler 가 있다.  
 그리고 여기에서 HTTP 메시지 컨버터를 호출해서 응답 결과를 만든다.
