# 💡 페이지(Page)란?

인덱스를 설명하기 전에 페이지(또는 블럭)의 개념을 알아야 한다. 페이지란 디스크와 버퍼풀(메모리)에 데이터를 읽고 쓰는 최소 작업 단위이다. 
일반적인 인덱스를 포함해 PK(클러스터 인덱스)와 테이블 등은 모두 페이지 단위로 관리된다.
따라서, 만약 **쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 블록을 읽어야 하는 것이다.**
그래서 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여, 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 상당히 중요하다. 
페이지에 저장되는 데이터의 크기가 클수록 다음과 같은 문제가 생길 수 있다.
- 디스크 I/O가 많아질 수 있음
- 메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음

만약 조회하는 레코드 건수가 많아서 1개의 페이지만으로 처리가 안된다면 다른 페이지를 읽어야 한다. 
이는 추가 디스크 읽기 작업을 의미하며, 읽어야 하는 페이지의 수 만큼 성능이 떨어지게 된다. 
데이터베이스 성능 개선 혹은 쿼리 튜닝은 디스크 I/O 자체를 줄이는 것이 핵심인 경우가 많은데, 그 만큼 디스크 I/O는 느리다. 
또한 메모리의 효율을 위해서도 중요하다. 
디스크 I/O를 통해 페이지를 읽어오면 버퍼풀이라는 메모리에 캐싱해둔다. 그런데 개별 데이터의 크기가 커지면 페이지 자체의 크기가 커지면서, 메모리에 캐싱해둘 수 있는 페이지 수도 줄어들게 되고 메모리 효율이 떨어지게 된다.

# 💡 클러스터 인덱스(Clustered Index)

클러스터 인덱스는 테이블 전체가 정렬된 인덱스가 되는 방식의 인덱스 종류이다. 
**실제 데이터와 무리(cluster)를 지어 인덱싱** 되므로 클러스터 인덱스라고 부른다. 
데이터와 함께 **전체 테이블이 물리적으로 정렬된다.**

클러스터 인덱스는 테이블당 하나만 생성할 수 있다. 
어떤 컬럼을 선택해 클러스터 인덱스를 만들지에 따라 성능이 좌우될 수 있다. 
클러스터 인덱스는 테이블 당 하나만 가질 수 있고, MySQL에서는 기본적으로 PK가 클러스터 인덱스이다. PK가 없으면 내부적으로 PK를 만들어내므로 모든 테이블이 클러스터 인덱스를 갖는다고 할 수 있다.

![image](https://github.com/user-attachments/assets/7f443ebf-48a1-410e-921d-6ab615a1def1)


클러스터 인덱스는 위 그림처럼 B+Tree의 형태로 구성되어 있다. 
여기서 B+Tree의 노드를 데이터베이스에서는 페이지라고 부른다. 
각 페이지는 고유의 페이지 번호를 가지고 있다. 
리프 노드에 실제 레코드의 모든 컬럼 값이 저장되어 있다는 점 때문에 조회속도가 매우 빠르다.

클러스터 인덱스는 물리적인 저장 위치를 저장한다. 그래서 조회 시에 처리가 매우 빠르다.
특히 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하는데, 랜덤 I/O는 임의의 장소에서 데이터를 가져오지만 순차 I/O는 다음 장소에서 데이터를 가져오므로 훨씬 빠르다. 
그 외에도 인덱스가 PK 값을 가지므로, 인덱스를 통해 PK만 조회하는 경우라면 내부 테이블까지 조회하지 않아도 되므로 효율적으로 처리된다.

# 💡 넌클러스터 인덱스 (Non-Clustered Index)

넌클러스터 인덱스는 보조 인덱스(Secondary Index)라고도 불리며, 클러스터 인덱스와 다르게 물리적으로 테이블을 정렬하지 않는다. 
그 대신 **정렬된 별도의 인덱스 페이지를 생성하고 관리한다.** 즉, **실제 데이터를 함께 가지고 있지 않다.**

![image](https://github.com/user-attachments/assets/b2a95be4-b4a6-4175-9f9a-73fafe380a06)

넌클러스터 인덱스는 **인덱스 페이지와 데이터 페이지가 구분되어있다.** 루트 페이지는 클러스터 인덱스와 비슷하게 인덱스에 대한 컬럼과 페이지 번호를 가지고 있다.
리프 페이지는 조금 다르다. 인덱스 컬럼을 가지고 있는 것은 비슷하지만, 데이터를 직접 가지고 있지 않으며 `데이터 페이지 번호 + #오프셋` 을 가지고 있어 **데이터 페이지의 특정 행을 가리킨다.**
즉, 데이터에 접근하기 위해서는 **인덱스 페이지에서 데이터 페이지로 이동하는 하나의 과정이 추가된다.**

인덱스 페이지는 정렬되어 있지만, 실제 데이터 페이지는 정렬되지 않으므로 클러스터 인덱스에 비해 삽입, 수정, 삭제 작업이 비교적 빠르다. 
데이터 페이지에는 정렬 순서 상관없이 빈 곳에 데이터를 삽입하면 되기 때문이다.

# 💡 클러스터 인덱스 & 넌클러스터 인덱스 혼합

실제로는 하나에 테이블에 클러스터 인덱스와 넌클러스터 인덱스가 혼합되어 있는 경우가 많다. 
PK는 기본적으로 존재하고, 추가로 조회가 자주 발생하는 컬럼에 대해 인덱스를 추가하기 때문이다.

이런 경우에는 넌클러스터 인덱스를 먼저 거치고, 이어서 클러스터 인덱스를 거쳐 데이터를 찾는다. 
이때, 넌클러스터 인덱스는 `데이터 페이지 번호 + #오프셋` 대신 클러스터 인덱스에 대한 컬럼 값을 갖는다.

![image](https://github.com/user-attachments/assets/d948c3d2-00cf-4e02-a300-fdf1faf1b5de)
