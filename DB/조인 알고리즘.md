# Previous

- 다수의 테이블에서 조인을 수행할 때 동시에 여러 테이블에 접근할 수 없기 때문에 접근하는 우선순위를 정하게 된다.
- 다수의 테이블에서 순서에 따라 차례로 테이블에 접근하고, 그 결과를 다음 테이블로 전달한다.
- 이 때 테이블에 접근하는 선후관계에 따라 `드라이빙 테이블`과 `드리븐 테이블`이라는 용어로 구분한다.
- 드라이빙 테이블과 드리븐 테이블을 어떻게 결합할지에 따라 다양한 정책이 존재하는데, 이를 조인 알고리즘이라고 한다.
- 드라이빙 테이블의 데이터가 너무 많이 반환되면 이후 드리븐 테이블에서 확인해야 할 데이터가 늘어나므로 드라이빙 테이블의 결과셋을 줄이는 것이 중요하다.
- 조인 조건절은 인덱스로 구성하는 것이 좋다.

# 💡 중첩 루프 조인 (nested loop join)

- 중첩 루프 조인(Nested loop join = NL join)은 드라이빙 테이블 데이터 1건당 드리븐 테이블을 반복해 검색하는 조인방식이다.
- 마치 2중 for문과 비슷하게 동작한다.
- 이 때 조인 조건절 열의 인덱스 존재유무가 성능에 영향을 미친다.
- 만약, 조인 조건절에 인덱스가 설정되어 있지 않다면 드라이빙 테이블의 데이터 1건마다 드리븐 테이블의 full table scan이 일어나게 된다.
- 참고로, 인덱스가 넌클러스터인덱스일 경우 인덱스를 이용해 테이블의 데이터를 찾는 과정에서 랜덤 액세스(random access)가 발생한다.
- 이런 이유로 드라이빙 테이블의 데이터가 적을 때 유리한 방식이다.

# 💡 블록 중첩 루프 조인 (block nested loop join)

- 블록 중첩 루프 조인(Block nested loop join = BNL join)은 중첩 루프 조인의 효율성을 높이기 위해 등장했다.
- 중첩 루프 조인에서 조인 조건절에 인덱스가 없을 경우 드라이빙 테이블 데이터 1건 당 드리븐 테이블에서 매번 full table scan이 발생하게 된다.
- 블록 중첩 루프 조인은 드라이빙 테이블의 데이터를 모두 검색해 조인 버퍼(join buffer)에 담아둔다. 모두 적재되면 드리븐 테이블과 조인 버퍼를 한번의 스캔으로 조인한다.
- 즉, 드리븐 테이블에 한번의 full table scan으로 조인을 완료할 수 있다.

# 💡 해시 조인 (hash join)

- 해시 조인은 NL join의 한계를 극복하기 위해 MySQL 8.0.18버전부터 지원하는 조인 방식이다.
- 해시 조인은 선후관계를 두고 조인하는 중첩 루프 조인 방식과 다르게 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행한다.
- 해시 조인은 다음 두 단계로 진행된다.
  - Build : 작은 테이블(small row set을 갖는 테이블)의 조인 컬럼을 키 값으로 해시 테이블을 만든다.
  - Probe : 큰 테이블의 조인 컬럼을 키 값으로 해시 테이블을 탐색하여 조인한다.
- 다만, 생성해야 하는 해시테이블의 크기에 따라 오버헤드가 발생할 수 있음에 유의해야 한다.
- 해시 조인은 보통 대용량 데이터의 동등 비교 연산('=')에서 자주 사용된다.
- 참고) MySQl은 NL join이 대량 데이터 조회시에 보이는 약점을 보완하기 위해 BNL join을 대안으로 사용해왔다. 하지만, BNL join은 8.0.18 버전 이후로 더 이상 사용되지 않고, BNL join이 사용될 상황에 Hash join이 사용되도록 변경되었다.
- 참고) Join Buffer가 8.0.18 버전 이후 hash join 용 메모리로 사용된다. hash join의 경우, join_buffer_size라는 시스템 변수 수치 이상의 메모리를 사용할 수 없고, 이를 초과하게 될 경우 디스크를 사용하게 된다.
