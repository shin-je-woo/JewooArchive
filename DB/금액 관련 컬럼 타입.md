# 금액 관련 값을 어떻게 저장할까?

### DB와 애플리케이션 관점에서 다시 생각해본 숫자 타입 선택

최근 프로젝트에서 금액·수량 같은 정밀도가 중요한 숫자 데이터를 어떻게 저장해야 할지 다시 고민하는 일이 있었다.

**DB 타입과 애플리케이션 타입이 함께 어떤 제약과 효과를 만들어내는지** 돌아보게 됐다.

아래는 금액 관련 타입으로 둘 수 있는 후보군을 선정하고, 운영 환경에서 맞닥뜨릴 수 있는 문제들을 기준으로 정리한 내용이다.

## 1. VARCHAR로 금액을 저장하는 방식

초기 설계 단계에서는 `VARCHAR`(문자열)로 저장하는 방식을 고려해볼 수 있다.

특히 암호화폐처럼 소수 자릿수가 코인마다 다를 때는 문자열이 범용적으로 보이기 때문에 더 그렇다.

하지만 운영을 시작하면 생각보다 많은 문제들이 드러난다.

### 1) 문자열은 숫자를 보장하지 않는다.

VARCHAR 컬럼은 다음과 같은 값까지 모두 받아들인다.

- `"1.23"`
- `" 1.23"`
- `"1e-8"`
- `"001.002"`
- `"abc"`

애플리케이션에서는 BigDecimal로 파싱하겠지만, DB는 이 값들이 숫자인지 아닌지 전혀 모른다.

즉 **숫자 검증 책임이 DB에서 애플리케이션으로 모두 넘어온다.**

### 2) DB 쿼리가 문자열 기준으로 움직인다

문자열 정렬의 대표적인 문제는 이것이다.

```sql
"100" < "20"   -- 문자열 기준
```

정렬도 문자열, 검색도 문자열 기준이다.

정확한 숫자 정렬이나 범위 요청을 하려면 매번 CAST를 써야 한다.

```sql
ORDER BY CAST(amount AS DECIMAL(38,18))
```

이렇게 되면 인덱스를 사용할 수 없고 성능도 떨어진다.

SELECT 결과가 이미 잘못되어 넘어오니, 애플리케이션에서 BigDecimal로 변환해도 의미가 없다.

### 3) BigDecimal 변환은 보완책일 뿐, 해결책은 아니다.

DB에서 문자열을 받아서 BigDecimal로 변환한다고 해서 문제가 해결되는 것은 아니다.

DB가 잘못된 데이터를 허용했다면, 파싱은 언제든 예외를 터뜨린다.

```java
new BigDecimal("1e-8"); // 기획 의도와 맞지 않을 수 있음
new BigDecimal("abc");  // NumberFormatException
```

이건 BigDecimal의 문제가 아니라, **DB 레벨에서 검증하지 않았기 때문에 생기는 문제**이다.

운영 중에 이런 값이 들어가기 시작하면 복구는 훨씬 더 어렵다.

## 2. Float/Double이 위험한 이유

금액 저장 방식으로 float/double을 고민하는 경우도 있는데, 정밀도 있는 숫자에서는 사실상 선택지에서 제외하는 것이 맞다.

### 1) float/double은 정확한 값이 아니라 근사값이다.

개발자 입장에서는 `0.1`, `0.2`, `0.3`이라고 입력했지만, 실제로 메모리에는 다음과 같은 값이 들어간다.

- 0.10000000000000000555
- 0.20000000000000001110
- 0.30000000000000004441

그래서 아래 코드가 `false`가 나올 수 있다.

```java
0.1 + 0.2 == 0.3  // false
```

이는 부동소수점을 다루는 **타입 특성**이다.

float/double의 존재 목적 자체가 “빠른 근사값 계산”이지 “정확한 십진수 저장”이 아니다.

### 2) 누적 연산에서 오차가 쌓인다.

금액 관련 로직에서는 반복 계산이 많다.

- 수수료 누적
- 포인트 적립/차감
- 시간 기반 정산
- 주문 체결 수량 누적

float/double로 이런 연산을 수행하면

1 → 2 → 3 → 4 … 반복될수록 오차가 반드시 누적된다.

결국 **1원 차이**, **0.00000002 단위 오차** 같은 문제가 쌓이고, 그 오차는 점점 복구하기 어려운 형태로 커지게 된다.

## 3. DECIMAL을 사용했을 때의 장점

MySQL의 `DECIMAL` 타입은 사람의 인지 방식과 동일한 십진수 표현이다.

Java에서는 BigDecimal과 정확하게 1:1로 대응한다.

### DB → 애플리케이션 사이에서 값이 손실되지 않는다.

`DECIMAL(38,18)` 값은 그대로 BigDecimal로 들어온다.

중간에 오차가 끼어들 여지가 없다.

### 쿼리가 의도대로 동작한다.

정렬, 비교, 범위 검색 모두 **숫자 기준**으로 동작한다.

- CAST 필요 없음
- 인덱스 정상 작동
- 숫자 검증은 DB에서 강제 가능

이 조합을 쓰면 애플리케이션 코드가 가장 단순해진다.

### 데이터 제약을 DB가 책임진다.

소수 자릿수, 음수 허용 여부, 값의 범위 등을 DB 차원에서 지정할 수 있다.

한 번 DB가 잘못된 값을 차단하면, 애플리케이션은 검증에 소모되던 많은 비용을 아낄 수 있다.

## 4. Bigint(정수 기반 저장)를 고려해야 하는 경우

특정 도메인에서는 금액이나 수량을 “최소 단위”로 저장하는 방식을 사용한다.

- 달러(센트 단위)
- satoshi(1 BTC = 100,000,000 satoshi)
- wei(1 ETH = 10^18 wei)

이 방식의 장점은 명확하다.

- 오차가 아예 발생하지 않는다
- 연산 속도는 DECIMAL보다 빠르다.
- long/BigInteger로 다루기 편하다.

단점은 하나다:

- **사용자에게 보여줄 땐 소수표현방식으로 변환해야 한다.**

정확성·속도·안정성이 필요한 도메인에서는 최종적으로 이 방법을 고려해볼 수 있다.

# 결론

### 1) DB에 문자열로 저장하는 방식은 권장되지 않는다.

애플리케이션에서 BigDecimal을 쓰더라도, DB가 문자열인 순간 무결성·정렬·검색·검증 문제를 떠안게 된다.

### 2) Float/Double은 금액·수량처럼 정밀한 값에는 절대 적합하지 않다

근사 계산 방식이기 때문에 오차는 피할 수 없다.

금융·정산 도메인에서는 고려하지 않는 것이 맞다.

### 3) 가장 무난하고 안정적인 선택은 DECIMAL + BigDecimal 조합

정확성, 쿼리 효율, 유지보수 측면에서 가장 균형이 좋다.

### 4) 더 깊은 안정성과 성능이 필요하다면 Bigint 기반 정수 저장도 고려

특히 코인·포인트·회계처럼 최소 단위가 명확한 도메인에 적합할 수 있다.
