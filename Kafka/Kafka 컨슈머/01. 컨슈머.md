# 💡 컨슈머

![image](https://github.com/user-attachments/assets/2063c782-bcee-479a-9ace-5ddc1e91918c)

- 프로듀서가 전송한 데이터는 카프카 브로커에 적재된다.
- 컨슈머는 적재된 데이터를 사용하기 위해 브로커로부터 데이터를 가져와서 필요한 처리를 한다.
- 예를 들어, 마케팅 문자를 고객에게 보내는 기능이 있다면 컨슈머는 토픽으로부터 고객 데이터를 가져와서 문자 발송 처리를 하게 된다.

# 💡 컨슈머 내부 구조

![image](https://github.com/user-attachments/assets/224642f7-57d9-454d-a400-d609ff49b98e)

- Fetcher : 리더 파티션으로부터 레코드들을 미리 가져와서 대기
- poll(): Fetcher에 있는 레코드들을 리턴.
- ConsumerRecords : 처리하고자 하는 레코드들의 모음. 오프셋이 포함되어 있다.

# 💡 컨슈머 그룹

![image](https://github.com/user-attachments/assets/010b6f25-27bf-4460-b97a-ad3e2e71914b)

- 컨슈머 그룹으로 운영하는 방법은 컨슈머를 각 컨슈머 그룹으로부터 격리된 환경에서 안전하게 운영할 수 있도록 도와주는 카프카의 독특한 방식이다.
- 컨슈머 그룹으로 묶인 컨슈머들은 토픽의 1개 이상 파티션에 할당되어 데이터를 가져갈 수 있다.
- 컨슈머 그룹으로 묶인 컨슈머가 토픽을 구독해서 데이터를 가져갈 때, 1개의 파티션은 최대 1개의 컨슈머에 할당 가능하다.
- 그리고 1개의 컨슈머는 여러 개의 파티션에 할당될 수 있다.
- 이러한 특징으로 컨슈머 그룹의 컨슈머 개수는 가져가고자 하는 토픽의 파티션 개수보다 같거나 작아야 한다.

### 컨슈머 그룹의 컨슈머가 파티션 개수보다 많을 경우

![image](https://github.com/user-attachments/assets/491f9061-8677-43fe-ae10-a577219fc9fa)

- 만약 4개의 컨슈머로 이루어진 컨슈머 그룹으로 3개의 파티션을 가진 토픽에서 데이터를 가져가기 위해 할당하면 1개의 컨슈머는 파티션을 할당받지 못하고 유휴 상태로 남게 된다.
- 파티션을 할당받지 못한 컨슈머는 스레드만 차지하고 실질적인 데이터 처리를 하지 못하므로 애플리케이션 실행에 있어 불필요한 스레드로 남게 된다.

# 💡 컨슈머 그룹을 활용하는 이유

![image](https://github.com/user-attachments/assets/2b7ca6d8-2017-452e-bc4c-32109ae34879)

- 운영 서버의 주요 리소스인 CPU, 메모리 정보를 수집하는 데이터 파이프라인을 구축한다고 가정해 보자.
- 실시간 리소스를 시간순으로 확인하기 위해서 데이터를 엘라스틱서치에 저장하고 이와 동시에 대용량 적재를 위해 하둡에 적재할 것이다.
- 만약 카프카를 활용한 파이프라인이 아니라면 서버에서 실행되는 리소스 수집 및 전송 에이전트는 수집한 리소스를 엘라스틱서치와 하둡에 적재하기 위해 동기적으로 적재를 요청할 것이다.
- 이렇게 동기로 실행되는 에이전트는 엘라스틱서치 또는 하둡 둘 중 하나에 장애가 발생한다면 더는 적재가 불가능할 수 있다.

![image](https://github.com/user-attachments/assets/ff7c0324-59e6-4a37-a45c-94626f4aa34e)

- 카프카는 이러한 파이프라인을 운영함에 있어 최종 적재되는 저장소의 장애에 유연하게 대응할 수 있다.
- 각기 다른 저장소에 저장하는 컨슈머를 다른 컨슈머 그룹으로 묶음으로써 각 저장소의 장애에 격리되어 운영할 수 있다.
- 따라서 엘라스틱서치의 장애로 인해 더는 적재가 되지 못하더라도 하둡으로 데이터를 적재하는 데에는 문제가 없다.
- 엘라스틱서치의 장애가 해소되면 엘라스틱서치로 적재하는 컨슈머의 컨슈머 그룹은 마지막으로 적재 완료한 데이터 이후부터 다시 적재를 수행하여 최종적으로 모두 정상화될 것이다.

# 💡 리밸런싱

![image](https://github.com/user-attachments/assets/5201f991-e5db-4ac0-b0ce-40b9428e671d)

- 컨슈머 그룹 내의 컨슈머들은 자신들이 읽는 파티션의 소유권을 공유한다.
- 즉, 하나의 컨슈머 그룹에서 컨슈머 A가 담당하던 파티션 읽기 작업을 컨슈머 B가 이관받아 작업을 처리할 수 있다.
- 이와 같은 컨슈머 그룹 내의 소유권 이관 작업을 리밸런싱(Rebalance, Rebalancing)이라고 한다.
- 이처럼 리밸런싱은 컨슈머의 파티션 소유권을 조정할 수 있기 때문에 컨슈머 그룹의 확장성과 가용성을 높여준다.
- 리밸런싱은 크게 두 가지 상황에서 일어난다.
  - **컨슈머 그룹의 멤버십 변화** : 컨슈머 그룹 내의 컨슈머가 제외되거나 추가됐을 경우
  - **새로운 파티션의 추가 혹은 변경** : 컨슈머 그룹이 구독하고 있는 토픽의 파티션이 추가 혹은 변경(re-assign) 된 경우
- 리밸런싱은 컨슈머가 데이터를 처리하는 도중에 언제든지 발생할 수 있으므로 데이터 처리 중 발생한 리밸런싱에 대응하는 코드를 작성해야 한다.

# 💡 커밋

![image](https://github.com/user-attachments/assets/0de87e47-312c-48b5-a7ff-f5059c02a16b)

- 컨슈머는 카프카 브로커로부터 데이터를 어디까지 가져갔는지 커밋(commit)을 통해 기록한다.
- 커밋은 어떤 컨슈머 그룹이 토픽의 파티션을 몇 번째까지 가져갔는지 카프카 브로커 내부에서 사용되는 내부 토픽 (_consumer_offsets)에 기록된다.
- 컨슈머 동작 이슈가 발생하여 __consumer_offsets 토픽에 어느 레코드까지 읽어갔는지 오프셋 커밋이 기록되지 못했다면 데이터 처리의 중복이 발생할 수 있다.
- 그러므로 데이터 처리의 중복이 발생하지 않게 하기 위해서는 컨슈머 애플리케이션이 오프셋 커밋을 정상적으로 처리했는지 검증해야 한다.

# 💡 어사이너(Assignor)

- 어사이너(Assignor)란? 컨슈머와 파티션의 할당 정책을 결정하는 것
- `RangeAssignor`: 각 토픽에서 파티션을 숫자로 정렬, 컨슈머를 사전 순서로 정렬해 할당
- `RoundRobinAssignor`: 모든 파티션을 컨슈머에서 번갈아가며 할당
- `StickyAssignor`: 최대한 파티션을 균등하게 배분하면서 할당
- 카프카 2.5.0 버전에서는 RangeAssignor가 기본값으로 설정된다.

# 💡 컨슈머 주요 옵션

## 필수 옵션 (default 값이 없음)

- `bootstrap.servers`: 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커의 호스트이름:포트를 1개 이상 작성한다. 2개 이상 브로커 정보를 입력하여 일부 브로커에 이슈가 발생하더라도 접속하는 데에 이슈가 없도록 설정 가능하다.
- `key.deserializer`: 레코드의 메시지 키를 역직렬화하는 클래스를 지정한다.
- `value.deserializer`: 레코드의 메시지 값을 역직렬화하는 클래스를 지정한다.

## 선택 옵션 (default 값 있음)

- `group.id`: 컨슈머 그룹 아이디를 지정한다. subscribe() 메서드로 토픽을 구독하여 사용할 때는 이 옵션을 필수로 넣어야 한다. 기본값은 null이다.
- `auto.offset.reset`: 컨슈머 그룹이 특정 파티션을 읽을 때 저장된 컨슈머 오프셋이 없는 경우 어느 오프셋부터 읽을지 선택하는 옵션이다. 이미 컨슈머 오프셋이 있다면 이 옵션값은 무시된다. 기본값은 latest이다.
- `enable.auto.commit`: 자동 커밋으로 할지 수동 커밋으로 할지 선택한다. 기본값은 true 이다.
- `auto.commit.interval.ms`: 자동 커밋일 경우 오프셋 커밋 간격을 지정한다. 기본값은 5000(5초)이다.
- `max.poll.records`: poll() 메서드를 통해 반환되는 레코드 개수를 지정한다. 기본값은 500 이다.
- `session.timeout.ms`: 컨슈머가 브로커와 연결이 끊기는 최대 시간이다. 기본값은 10000(10초)이다.
- `hearbeat.interval.ms`: 하트비트를 전송하는 시간 간격이다. 기본값은 3000(3초)이다.
- `max.poll.interval.ms`: poll() 메서드를 호출하는 간격의 최대 시간. 기본값은 300000(5분)이다.
- `isolation.level`: 트랜잭션 프로듀서가 레코드를 트랜잭션 단위로 보낼 경우 사용한다.

### auto.offset.reset

- 컨슈머 그룹이 특정 파티션을 읽을 때 저장된 컨슈머 오프셋이 없는 경우 어느 오프셋부터 읽을지 선택하는 옵션이다. 커밋을 한 번이라도 한 경우에는 이 옵션값이 무시된다.
- `latest`: 가장 높은(가장 최근에 넣은) 오프셋부터 읽기 시작 (기본값)
- `earliest`: 가장 낮은(가장 오래전에 넣은) 오프셋부터 읽기 시작
- `none`: 컨슈머 그룹이 커밋한 기록이 있는지 찾고 없으면 오류 반환. 있다면 기존 커밋 기록 이후 오프셋부터 읽기 시작한다. 
