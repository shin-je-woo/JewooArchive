개발을 하다보면 컴포넌트 간에 의존성이 발생하게 된다.

특히, 계층형 아키텍처에서는 계층 간 의존성이 항상 아래를 향한다. (웹 -> 도메인 -> 영속성)

이는 영속성 계층이 변경되면 도메인 계층도 변경해야 함을 의미한다.

그러나, 영속성 코드가 바뀐다고 해서 도메인 코드가 바뀌는 것이 올바른 설계일까?

도메인 코드는 애플리케이션에서 가장 중요한 코드이기 때문에 영속성 계층에 대한 의존성을 제거해야 한다.

의존성 역전 원칙(DIP)을 적용하면 이 문제를 해결할 수 있다.

도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하도록 해보자. 그러면 도메인 코드를 변경할 이유가 줄어들게 된다. (SRP)

![image](https://github.com/user-attachments/assets/779d9e62-dc07-4784-92e8-0be35ec8e49b)

도메인 계층과 영속성 계층의 의존성을 역전시키면서 도메인Entity와 ORM Entity가 분리되었다.

둘의 차이는 간단하게 다음과 같다.

도메인 Entity: 비즈니스 도메인 관점에서 문제를 해결하기 위한 객체이다. 엔티티의 정체성(identity)은 ID로 표현된다.

ORM Entity: javax.persistence 패키지의 @Entity라는 애너테이션이 붙어있다. Persistence, 즉 데이터베이스와 매핑이 되는 객체이다. 식별이 가능한 키, 즉 @Id 필드가 필요하다.

### 클린 아키텍처에서 의존성 역전이 중요한 이유

클린 아키텍처에서 비즈니스 규칙은 데이터베이스, UI기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적이어야 한다.

이 말은, 도메인 영역에서 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다.

도메인 영역을 독립적으로 구성하기 위해 의존성 역전 원칙을 적용해서 도메인 영역에서 외부로 향하는 의존성을 제거한다.

![image](https://github.com/user-attachments/assets/56f451b4-bd7e-42d0-8011-e40278efc350)

클린 아키텍처에서 가장 주요한 규칙은 의존성 규칙으로, 계층 간의 모든 의존성이 안쪽으로 향해야 한다.

도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고, 비즈니스 규칙에 집중할 수 있다.

![image](https://github.com/user-attachments/assets/bfbd43e8-fe6e-40e9-947a-45a3a2cb9536)

헥사고날 아키텍처에서도 도메인 영역에서 외부로 향하는 의존성이 없기 때문에 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된다.

이렇게 의존성을 역전시키게 되면 도메인 코드가 독립적으로 구성되고, 영속성이나 UI와 관련된 문제로부터 영향을 받지 않게 된다.

즉, 도메인 로직의 결합을 제거하고 코드를 변경할 이유를 줄여 유지보수성을 높일 수 있다.
