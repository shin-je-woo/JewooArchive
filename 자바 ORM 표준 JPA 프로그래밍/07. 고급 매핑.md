# 💡 상속관계 매핑
* 관계형 데이터베이스는 상속 관계가 없다.
* 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
* 상속관계 매핑: 객체의 상속과 DB의 슈퍼타입 서브타입 관계를 매핑

![image](https://user-images.githubusercontent.com/39439576/230848796-d4a28175-d505-4b57-94ec-31ea4fee9834.png)
### 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법

### ✅ 조인 전략
![image](https://user-images.githubusercontent.com/39439576/230852068-c08bd3d9-015d-46e6-a84a-816b4949fbed.png)
* 장점
  * 테이블 정규화
  * 외래 키 참조 무결성 제약조건 활용가능
  * 저장공간 효율화

* 단점
  * 조회시 조인을 많이 사용, 성능 저하
  * 조회 쿼리가 복잡함
  * 데이터 저장시 INSERT SQL 2번 호출

### ✅ 단일 테이블 전략
![image](https://user-images.githubusercontent.com/39439576/230852664-f8604cdb-0766-4965-a528-c45e59cca6f6.png)
* 논리모델을 한 테이블로 합쳐버리는 방법.
* 한 테이블에 다 넣어 놓고 어떤 테이블인지 구분하는 컬럼(ex:DTYPE)을 통해 구분한다.
* 테이블은 ITEM 테이블 하나만 관리된다.
* 성능에서 우위를 가질 수 있다. (select or insert 가 한번 수행 된다.)
* @DiscriminatorColumn 이 필수로 들어간다. (기입하지 않아도 자동으로 들어감)

* 장점
  * 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
  * 조회 쿼리가 단순함
* 단점
  * 자식 엔티티가 매핑한 컬럼은 모두 null 허용
  * 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 
  * 상황에 따라서 조회 성능이 오히려 느려질 수 있다. (하지만, 임계점을 넘을 정도의 상황은 거의 오지 않는다.)

### ✅ 구현 클래스마다 테이블 전략
* 각각의 테이블마다 별개로 만들어서 따로 관리
* ITEM 테이블을 생성하지 않고 ALBUM, MOVIE, BOOK 테이블에서 각각 id, name, price필드를 가지고 있다.
* @DiscriminatorColumn을 사용할 수 없다.(구분 할 이유가 없다.)
* ITEM을 조회하면 ALBUM, MOVIE, BOOK 세개의 테이블을 UNION ALL으로 전부 조회해서 가져온다.(단점)
* 추천하지 않는 전략(개발자,DBA 양측에서)
장점
  * 서브 타입을 명확하게 구분해서 처리할 때 효과적
  * not null 제약조건 사용 가능
* 단점
  * 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
  * 자식 테이블을 통합해서 쿼리하기 어려움

# 💡 @MappedSuperclass
* 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
* 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용
* 참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능

![image](https://user-images.githubusercontent.com/39439576/230854800-a60941cc-e27c-44c8-8a06-4f6881744d9a.png)
* 상속관계 매핑이 아니다.
* 엔티티도 아니고, 테이블과 매핑되지도 않는다.
* 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공
* 부모타입으로 조회, 검색 불가 (em.find(BaseEntity) 불가)
* 직접 생성해서 사용할 일이 없으므로 추상클래스 권장
