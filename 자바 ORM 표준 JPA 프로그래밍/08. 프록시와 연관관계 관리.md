# 💡 프록시
### 프록시 기초

✅ em.find() vs em.getReference() 
* em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회
* em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

![image](https://user-images.githubusercontent.com/39439576/231021875-05e73775-39a4-43a2-b1a5-356279c931bb.png)

### 프록시 특징
* 실제 클래스를 상속 받아서 만들어진다.
* 실제 클래스와 겉 모양이 같다.
* 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.(이론상)
* 프록시 객체는 실제 객체의 참조(target)를 보관한다.
* 프록시 객체를 호출(getName())하면 프록시 객체는 실제 객체의 메소드 호출

![image](https://user-images.githubusercontent.com/39439576/231022091-4334dd70-2a1b-4beb-bc12-2a34ff8f96db.png)

* 프록시 객체는 처음 사용할 때 한 번만 초기화
* 프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
* 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비교 실패, 대신 instance of 사용)
* 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
* 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생  
  → (하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)

### 프록시 객체의 초기화
![image](https://user-images.githubusercontent.com/39439576/231022868-fb3bcd35-6b58-4cff-8d55-6f3596f0fcc8.png)
* em.getReference() 메소드로 Member엔티티의 프록시 객체를 조회한다.
* 프록시 객체를 호출할 때(member.getName()) 영속성 컨텍스트에 실제 엔티티 조회를 요청하는데 이것을 초기화라 한다.
* 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
* 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버 변수에 보관한다.
* 프록시 객체는 실제 엔티티 객체의 getName() 을 호출(위임)해서 결과를 반환한다.

### 프록시 확인
* 프록시 인스턴스의 초기화 여부 확인  
  PersistenceUnitUtil.isLoaded(Object entity) → entityManagerFactory.getPersistenceUnitUtil().isLoaded(object)
* 프록시 클래스 확인 방법  
  entity.getClass().getname() 출력(..javasist.. or HibernateProxy...)
* 프록시 강제 초기화  
  org.hibernate.Hibernate.initialize(entity);
* 참고: JPA 표준은 강제 초기화 없음  
  강제 호출: method.getName();

# 💡 즉시 로딩과 지연 로딩
### 지연로딩
❓ Member를 조회할 때 Team(연관관계)도 함께 조회해야 할까?  
   : 단순히 member 정보만 사용하는 비즈니스 로직
   
▶️ 지연 로딩 LAZY을 사용해서 프록시로 조회
```java
@Entity
public class Member {
    ...
    @ManyToOne(fetch = FetchType.LAZY) //지연로딩 사용
    @JoinColumn(name="TEAM_ID")
    private Team team;
    ...
}
...
Member m = em.find(Member.class, member1.getId()); //Member 객체 반환
System.out.println("m = "+ m.getTeam().getClass()); //Team$HibernateProxy객체 반환
m.getTeam().getName() // 실제 team을 사용하는 시점에 프록시 초기화(DB 조회)
...
```

### 즉시 로딩
❓ Member와 Team을 같이 쓰는 빈도가 높을 경우에는 어떻게 해야 할까?

▶️ 즉시 로딩 EAGER를 사용해서 함께 조회
```java
@Entity
public class Member {
    ...
    @ManyToOne(fetch = FetchType.EAGER) //즉시로딩 사용
    @JoinColumn(name="TEAM_ID")
    private Team team;
    ...
}
...
Member m = em.find(Member.class, member1.getId()); //Member 객체 반환
System.out.println("m = "+ m.getTeam().getClass()); //Team 객체 반환(프록시가 아닌 실제 엔티티)
...
```

### ❗ 프록시와 즉시로딩 주의
* 가급적 지연 로딩만 사용(특히 실무에서)
* 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
* 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.  
▶️ N+1 문제 예시
```java
public class Member {
    ...
    @ManyToOne(fetch = FetchType.EAGER) //즉시로딩 사용
    @JoinColumn(name="TEAM_ID")
    private Team team;
    ...
}
...
List<Member> members = em.createQuery("select m from Member m", Member.class)
                          .getResultList();
//
//SQL: select * from Member
//SQL: select * from Team where TEAM_ID = xxx << 멤버 수만큼 수행됨!!
...
```
위 JPQL을 그대로 쿼리로 번역하게 되면 Member를 가져오기 위한 쿼리 수행 이후 바로 Member 내부의 Team을 가져오기 위한 쿼리를 다시 수행하게 된다 → N+1(1개의 쿼리를 날리면 +N개의 쿼리가 추가 수행된다.)
* @ManyToOne, @OneToOne은 기본이 즉시 로딩 -> 직접 전부 LAZY로 설정
* @OneToMany, @ManyToMany는 기본이 지연 로딩

