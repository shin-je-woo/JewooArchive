# 💡 반환 타입
스프링 데이터 JPA는 유연한 반환 타입 지원
```java
List<Member> findByUsername(String name); //컬렉션
Member findByUsername(String name); //단건
Optional<Member> findByUsername(String name); //단건 Optional
```
* 컬렉션
  * 결과 없음: 빈 컬렉션 반환
* 단건 조회
  * 결과 없음: null 또는 Optional.empty() 반환
  * 결과가 2건 이상: javax.persistence.NonUniqueResultException 예외 발생

> 📌 참고   
> 단건으로 지정한 메서드를 호출하면 스프링 데이터 JPA는 내부에서 JPQL의 `Query.getSingleResult()` 메서드를 호출한다.  
> 이 메서드를 호출했을 때 조회 결과가 없으면 `javax.persistence.NoResultException` 예외가 발생하는데 개발자 입장에서 다루기가 상당히 불편하다.   
> 스프링 데이터 JPA는 단건을 조회할 때 이 예외가 발생하면 예외를 무시하고 대신에 null 을 반환한다.

# 💡 페이징과 정렬
* JPA에서 페이징을 어떻게 할 것인가?
* 다음 조건으로 페이징과 정렬을 사용하는 예제 코드를 보자.
  * 검색 조건: 나이가 10살
  * 정렬 조건: 이름으로 내림차순
  * 페이징 조건: 첫 번째 페이지, 페이지당 보여줄 데이터는 3건
 
## 순수 JPA 페이징과 정렬
▶️ Repository
```java
public List<Member> findByPage(int age, int offset, int limit) {
    return em.createQuery("select m from Member m where m.age = :age order by m.username desc", Member.class)
            .setParameter("age", age)
            .setFirstResult(offset)
            .setMaxResults(limit)
            .getResultList();
}
```
▶️ TestCode
```java
@Test
public void paging() {
    //given
    memberJpaRepository.save(new Member("member1", 10));
    memberJpaRepository.save(new Member("member2", 10));
    memberJpaRepository.save(new Member("member3", 10));
    memberJpaRepository.save(new Member("member4", 10));
    memberJpaRepository.save(new Member("member5", 10));

    int age = 10;
    int offset = 0;
    int limit = 3;

    //when
    List<Member> members = memberJpaRepository.findByPage(age, offset, limit);
    long totalCount = memberJpaRepository.totalCount(age);

    //then
    assertThat(members.size()).isEqualTo(3);
    assertThat(totalCount).isEqualTo(5);
}
```

## 스프링 데이터 JPA 페이징과 정렬
* 스프링 데이터 프로젝트에서는 다음과 같이 페이징과 정렬을 공통화 해두었다.

### 페이징과 정렬 파라미터
* `org.springframework.data.domain.Sort` : 정렬 기능
* `org.springframework.data.domain.Pageable` : 페이징 기능 (내부에 Sort 포함)

### 특별한 반환 타입
* `org.springframework.data.domain.Page` : 추가 count 쿼리 결과를 포함하는 페이징
* `org.springframework.data.domain.Slice` : 추가 count 쿼리 없이 다음 페이지만 확인 가능 (내부적으로 limit + 1조회)
* List (자바 컬렉션): 추가 count 쿼리 없이 결과만 반환

▶️ 페이징과 정렬 사용 예제
```java
Page<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 
Slice<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안 함
List<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안 함
List<Member> findByUsername(String name, Sort sort);
```

▶️ Repository
```java
public interface MemberRepository extends Repository<Member, Long> {
    Page<Member> findByAge(int age, Pageable pageable);
}
```
▶️ TestCode
```java
@Test
public void paging() {
    //given
    memberRepository.save(new Member("member1", 10));
    memberRepository.save(new Member("member2", 10));
    memberRepository.save(new Member("member3", 10));
    memberRepository.save(new Member("member4", 10));
    memberRepository.save(new Member("member5", 10));

    //when
    PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC, "username"));
    Page<Member> page = memberRepository.findByAge(10, pageRequest);

    //then
    List<Member> content = page.getContent();

    assertThat(content.size()).isEqualTo(3); //조회된 데이터 수
    assertThat(page.getTotalElements()).isEqualTo(5); //전체 데이터 수
    assertThat(page.getNumber()).isEqualTo(0); //페이지 번호
    assertThat(page.getTotalPages()).isEqualTo(2); //전체 페이지 번호
    assertThat(page.isFirst()).isTrue(); //첫번째 항목인가?
    assertThat(page.hasNext()).isTrue(); //다음 페이지가 있는가?
}
```
* 두 번째 파라미터로 받은 `Pageable` 은 인터페이스다. 
* 따라서 실제 사용할 때는 해당 인터페이스를 구현한 `org.springframework.data.domain.PageRequest` 객체를 사용한다.
* `PageRequest` 생성자의 첫 번째 파라미터에는 현재 페이지를, 두 번째 파라미터에는 조회할 데이터 수를 입력한다. 
* 여기에 추가로 정렬 정보도 파라미터로 사용할 수 있다. 참고로 페이지는 0부터 시작한다.

### 참고) count 쿼리를 다음과 같이 분리할 수 있음
→ 복잡한 쿼리에서 count쿼리는 굳이 join을 할 필요가 없기 때문에 복잡한 sql을 사용하는 경우에는 분리해서 사용한다. 
```java
@Query(value = "select m from Member m",
       countQuery = "select count(m) from Member m")
Page<Member> findByAge(int age, Pageable pageable);
```

### 페이지를 유지하면서 엔티티를 DTO로 변환하기
→ 실무에서 엔티티를 그대로 반환하는 것은 위험하다. 그렇기 때문에 엔티티를 DTO로 변환하여 반환해야 한다.
```java
Page<Member> page = memberRepository.findByAge(age, pageRequest);
Page<MemberDTO> dtoPage = page.map(m -> new MemberDTO(m.getId(), m.getUsername(), null));
```
