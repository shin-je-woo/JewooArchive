# 💡 Previous
- 기존 코드의 변경 없이 부가기능을 추가하기 위해 프록시를 사용하는 데코레이터 패턴을 도입했다.
- 그리고, 프록시 클래스를 각각 생성해야 하는 문제를 보완하기 위해 동적프록시를 도입했다.
- 동적프록시 기술은 크게 두가지가 있다.
- **JDK 동적프록시**
  - 실제객체의 인터페이스가 필수로 있어야 한다.
  - 공통 부가기능을 `InvocationHandler` 인터페이스의 구현체에 둔다.
  - `Proxy.newProxyInstance` 메서드에 인터페이스 정보와 핸들러를 넘겨주며 프록시객체를 생성한다.
- **CGLIB 라이브러리**
  - 실제객체의 인터페이스가 없어도 프록시를 만들 수 있다.
  - 공통 부가기능을 `MethodInterceptor` 인터페이스의 구현체에 둔다.
  - `Enhancer` 객체로 프록시객체를 생성한다.
- 그렇다면 실제객체의 인터페이스 존재유무에 따라 다른 기술을 사용해야 할까?
- 이런 고민을 덜어주는 것이 바로 스프링의 프록시 팩토리이다.

# 💡 프록시 팩토리
## 프록시 팩토리란?
- 프록시 팩토리란 스프링에서 동적 프록시를 통합해서 편리하게 만들어주는 추상화된 기술이다.
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다. 그리고 이 설정을 변경할 수도 있다.
- 프록시 팩토리의 존재로 다음과 같은 동적 프록시의 한계를 해결할 수 있다.

## 인터페이스 유무에 따른 기술 선택
![image](https://github.com/shin-je-woo/TIL/assets/39439576/35cf9223-ad27-41b3-9a4c-76f9af12660b)
- 기존에 프록시객체를 생성할 때는 if 문으로 직접 인터페이스 유무를 확인하고, 기술에 따른 프록시객체 생성방식을 사용하여야 했다.
- 이제는 프록시팩토리에 실제객체를 넘겨주며 프록시객체를 생성한다.
- 이 때 프록시팩토리는 실제객체의 인터페이스 유무를 확인하고, 기술을 자동으로 선택하여 프록시객체를 생성해준다.

## Advice 의 도입
![image](https://github.com/shin-je-woo/TIL/assets/39439576/023641e7-d4e8-4f9c-89c2-68497d69b0e9)
- 두 기술을 함께 사용할 때 부가 기능을 적용하기 위해 JDK 동적 프록시가 제공하는 `InvocationHandler` 와 CGLIB가 제공하는 `MethodInterceptor` 를 각각 중복으로 따로 만들어야 할까?
- 스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 `Advice` 라는 새로운 개념을 도입했다.
- `InvocationHandler` 나 `MethodInterceptor` 를 신경쓰지 않고, `Advice` 만 만들면 된다.
- 결과적으로 `InvocationHandler` 나 `MethodInterceptor` 는 `Advice` 를 호출하게 된다.

## Pointcut 의 도입
- 기존에 Handler 내부에 특정 조건을 만족할 때만 부가기능을 적용하는 로직이 포함되었다.
- Handler 가 부가기능+적용여부를 모두 결정하는 것이다.
- 이는 SRP 에 위배되며, 이를 위해 `Pointcut` 이라는 개념을 도입해 `Pointcut` 에서 부가기능 적용여부를 확인하도록 하였다.
