# 💡 스프링 트랜잭션 전파 - 외부 롤백
- 이번에는 내부 트랜잭션은 커밋되는데, 외부 트랜잭션이 롤백되는 상황을 알아보자.
- 논리 트랜잭션이 하나라도 롤백되면 전체 물리 트랜잭션은 롤백된다.
- 따라서 이 경우 내부 트랜잭션이 커밋 했어도, 내부 트랜잭션 안에서 저장한 데이터도 모두 함께 롤백된다.

![image](https://github.com/shin-je-woo/TIL/assets/39439576/380012ac-a1f4-49ee-bb5e-b6f0697bc164)
- 요청 흐름은 앞에서 본 트랜잭션 참여와 같으므로 생략. 이번에는 응답 흐름에 집중.

#### 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다.
2. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.  
   이 경우 신규 트랜잭션이 아니기 때문에 실제 커밋을 호출하지 않는다.  
   이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다.  
   아직 트랜잭션이 끝난 것이 아니기 때문에 실제 커밋을 호출하면 안된다.  
   물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 한다.
   
#### 응답 흐름 - 외부 트랜잭션
3. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 롤백한다.
4. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.  
   외부 트랜잭션은 신규 트랜잭션이다.  
   따라서 DB 커넥션에 실제 롤백을 호출한다.
5. 트랜잭션 매니저에 롤백하는 것이 논리적인 롤백이라면, 실제 커넥션에 롤백하는 것을 물리 롤백이라 할 수 있다.  
   실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.
   
# 💡 스프링 트랜잭션 전파 - 내부 롤백
- 이번에는 내부 트랜잭션은 롤백되는데, 외부 트랜잭션이 커밋되는 상황을 알아보자.
- 내부 트랜잭션이 롤백될 때는 `Participating transaction failed - marking existing transaction as rollbackonly` 라는 로그가 발생한다.  
  → 내부 트랜잭션을 롤백하면 실제 물리 트랜잭션은 롤백하지 않는다. 대신에 기존 트랜잭션을 롤백 전용으로 표시한다.
- 이후 외후 트랜잭션이 커밋될 때 `Global transaction is marked as rollback-only` 라는 로그가 발생한다.  
  → 커밋을 호출했지만, 전체 트랜잭션이 롤백 전용으로 표시되어 있다. 따라서 물리 트랜잭션을 롤백한다.
  
![image](https://github.com/shin-je-woo/TIL/assets/39439576/85c52e2a-6c56-4226-9556-85ed96dd7d31)
#### 응답 흐름 - 내부 트랜잭션
1. 로직2가 끝나고 트랜잭션 매니저를 통해 내부 트랜잭션을 롤백한다. (로직2에 문제가 있어서 롤백한다고 가정한다.)
2. 트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.  
   이 경우 신규 트랜잭션이 아니기 때문에 실제 롤백을 호출하지 않는다.  
   이 부분이 중요한데, 실제 커넥션에 커밋이나 롤백을 호출하면 물리 트랜잭션이 끝나버린다.  
   아직 트랜잭션이 끝난 것이 아니기 때문에 실제 롤백을 호출하면 안된다.  
   물리 트랜잭션은 외부 트랜잭션을 종료할 때까지 이어져야 한다.
3. 내부 트랜잭션은 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 `rollbackOnly=true` 라는 표시를 해둔다.

#### 응답 흐름 - 외부 트랜잭션
4. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다.
5. 트랜잭션 매니저는 커밋 시점에 신규 트랜잭션 여부에 따라 다르게 동작한다.  
   외부 트랜잭션은 신규 트랜잭션이다. 따라서 DB 커넥션에 실제 커밋을 호출해야 한다.  
   이때 먼저 트랜잭션 동기화 매니저에 롤백 전용( `rollbackOnly=true` ) 표시가 있는지 확인한다.  
   롤백 전용 표시가 있으면 물리 트랜잭션을 커밋하는 것이 아니라 롤백한다.
6. 실제 데이터베이스에 롤백이 반영되고, 물리 트랜잭션도 끝난다.
7. 트랜잭션 매니저에 커밋을 호출한 개발자 입장에서는 커밋을 기대했는데 롤백 전용 표시로 인해 실제로는 롤백이 되어버렸다.  
   - 시스템 입장에서는 커밋을 호출했지만 롤백이 되었다는 것은 분명하게 알려주어야 한다.
   - 예를 들어서 고객은 주문이 성공했다고 생각했는데, 실제로는 롤백이 되어서 주문이 생성되지 않은 것이다.
   - 스프링은 이 경우 `UnexpectedRollbackException` 런타임 예외를 던진다. 
   - 그래서 커밋을 시도했지만, 기대하지 않은 롤백이 발생했다는 것을 명확하게 알려준다.

## 정리
- 논리 트랜잭션이 하나라도 롤백되면 물리 트랜잭션은 롤백된다.
- 내부 논리 트랜잭션이 롤백되면 롤백 전용 마크를 표시한다.
- 외부 트랜잭션을 커밋할 때 롤백 전용 마크를 확인한다. 
- 롤백 전용 마크가 표시되어 있으면 물리 트랜잭션을 롤백하고, `UnexpectedRollbackException` 예외를 던진다.

# 💡 스프링 트랜잭션 전파 - REQUIRES_NEW
- 이번에는 외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 사용하는 방법에 대해서 알아보자.
- 외부 트랜잭션과 내부 트랜잭션을 완전히 분리해서 각각 별도의 물리 트랜잭션을 사용하는 방법이다.
- 그래서 커밋과 롤백도 각각 별도로 이루어지게 된다.
- `REQUIRES_NEW` 옵션을 사용하면 물리 트랜잭션이 명확하게 분리된다.
- `REQUIRES_NEW` 를 사용하면 데이터베이스 커넥션이 동시에 2개 사용된다는 점을 주의해야 한다.

```
내부 트랜잭션 시작
Suspending current transaction, creating new transaction with name [null]
Acquired Connection [HikariProxyConnection@778350106 wrapping conn1] for JDBC
transaction
Switching JDBC Connection [HikariProxyConnection@778350106 wrapping conn1] to
manual commit
inner.isNewTransaction()=true

내부 트랜잭션 롤백
Initiating transaction rollback
Rolling back JDBC transaction on Connection [HikariProxyConnection@778350106
wrapping conn1]
Releasing JDBC Connection [HikariProxyConnection@778350106 wrapping conn1]
after transaction
Resuming suspended transaction after completion of inner transaction
```
- `REQUIRES_NEW` 옵션으로 내부 트랜잭션이 실행될 때 `Suspending current transaction` 라는 로그가 발생한다.
- 이는 내부 트랜잭션의 커넥션을 얻기 위해 기존 트랜잭션을 지연시킨다는 뜻이다.
- 이런 점 때문에 `REQUIRES_NEW` 옵션을 사용할 때는 주의가 필요하다.
- `Resuming suspended transaction after completion of inner transaction` 로그를 보면 내부 트랜잭션이 완전히 끝난 후 기존 트랜잭션을 다시 진행하는 것을 알 수 있다.

# 💡 스프링 트랜잭션 전파 - 다양한 전파 옵션
- 스프링은 다양한 트랜잭션 전파 옵션을 제공한다. 
- 전파 옵션에 별도의 설정을 하지 않으면 `REQUIRED` 가 기본으로 사용된다.
- 참고로 실무에서는 대부분 `REQUIRED` 옵션을 사용한다. 그리고 아주 가끔 `REQUIRES_NEW` 을 사용하고, 나머지는 거의 사용하지 않는다. 
- 그래서 나머지 옵션은 이런 것이 있다는 정도로만 알아두고 필요할 때 찾아보자.

#### REQUIRED
- 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음 : 기존 트랜잭션에 참여한다.

#### REQUIRES_NEW
- 기존 트랜잭션 없음 : 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음 : 새로운 트랜잭션을 생성한다.

#### SUPPORT
- 기존 트랜잭션 없음: 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음: 기존 트랜잭션에 참여한다.

#### NOT_SUPPORT
- 기존 트랜잭션 없음: 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음: 트랜잭션 없이 진행한다. (기존 트랜잭션은 보류한다)

#### MANDATORY
- 기존 트랜잭션 없음: IllegalTransactionStateException 예외 발생
- 기존 트랜잭션 있음: 기존 트랜잭션에 참여한다.

#### NEVER
- 기존 트랜잭션 없음: 트랜잭션 없이 진행한다.
- 기존 트랜잭션 있음: IllegalTransactionStateException 예외 발생

#### NESTED
- 기존 트랜잭션 없음: 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션 있음: 중첩 트랜잭션을 만든다.
  -  중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 중첩 트랜잭션은 외부에 영향을 주지 않는다.
  -  중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋할 수 있다.
  -  외부 트랜잭션이 롤백 되면 중첩 트랜잭션도 함께 롤백된다.

#### 트랜잭션 전파와 옵션
- `isolation` , `timeout` , `readOnly` 는 트랜잭션이 처음 시작될 때만 적용된다. 
- 트랜잭션에 참여하는 경우에는 적용되지 않는다.
- 예를 들어서 `REQUIRED` 를 통한 트랜잭션 시작, `REQUIRES_NEW` 를 통한 트랜잭션 시작 시점에만 적용된다.
