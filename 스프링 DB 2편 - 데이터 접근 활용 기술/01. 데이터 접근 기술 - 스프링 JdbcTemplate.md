# 💡 JdbcTemplate 소개
* SQL을 직접 사용하는 경우에 스프링이 제공하는 `JdbcTemplate` 은 아주 좋은 선택지다. 
* `JdbcTemplate` 은 JDBC를 매우 편리하게 사용할 수 있게 도와준다.

### 장점
✅ 설정의 편리함
* JdbcTemplate은 `spring-jdbc` 라이브러리에 포함되어 있다. (스프링으로 JDBC를 사용할 때 기본으로 사용되는 라이브러리)
* 별도의 복잡한 설정 없이 바로 사용 가능하다.

✅ 반복 문제 해결
* JdbcTemplate은 템플릿 콜백 패턴을 사용해서 JDBC를 직접 사용할 때 발생하는 대부분의 반복 작업을 대신 처리해준다.
* 개발자는 SQL 작성, 전달할 파리미터 정의, 응답 값 매핑만 하면 된다.
* 다음과 같은 대부분의 반복 작업을 대신 처리해준다.
  * `Connection` 획득
  * `Statement` 를 준비하고 실행
  * 결과(`ResultSet`)를 반복하도록 루프를 실행
  * `Connection` , `Statement` , `Resultset` 종료
  * 트랜잭션을 다루기 위한 커넥션 동기화
  * 예외 발생시 스프링 예외 변환기 실행

### 단점
* 동적 SQL을 해결하기 어렵다.

# 💡 JdbcTemplate 적용1 - 기본
```java
@Slf4j
public class JdbcTemplateItemRepositoryV1 implements ItemRepository {

    private final JdbcTemplate template;

    // 생성자 - JdbcTemplate은 DataSource가 필요하다.
    public JdbcTemplateItemRepositoryV1(DataSource dataSource) {
        this.template = new JdbcTemplate(dataSource);
    }
    
    @Override
    public Item save(Item item) {
        String sql = "insert into item (item_name, price, quantity) values (?,?,?)";
        KeyHolder keyHolder = new GeneratedKeyHolder();
        // 데이터를 변경할 때는 update() 를 사용
        template.update(connection -> {
            // 자동 증가 키 - 데이터베이스가 PK인 ID를 대신 생성
            PreparedStatement ps = connection.prepareStatement(sql, new String[]{"id"});
            ps.setString(1, item.getItemName());
            ps.setInt(2, item.getPrice());
            ps.setInt(3, item.getQuantity());
            return ps;
        }, keyHolder);

        long key = Objects.requireNonNull(keyHolder.getKey()).longValue();
        item.setId(key);

        return item;
    }
    ...
    private RowMapper<Item> itemRowMapper() {
        return ((rs, rowNum) -> {
            Item item = new Item();
            item.setId(rs.getLong("id"));
            item.setItemName(rs.getString("item_name"));
            item.setPrice(rs.getInt("price"));
            item.setQuantity(rs.getInt("quantity"));
            return item;
        });
    }
}
```
### template.update()
* 데이터를 변경할 때 사용한다.
* INSERT, UPDATE, DELETE SQL에 사용한다.
* template.update() 의 반환 값은 int 인데, 영향 받은 로우 수를 반환한다.

### template.queryForObject()
* 결과가 하나일 때 사용한다.
* `RowMapper` 는 데이터베이스의 반환 결과인 `ResultSet` 을 객체로 변환한다.

### template.query()
* 결과가 하나 이상일 때 사용한다.
* 마찬가지로 `RowMapper` 는 데이터베이스의 반환 결과인 `ResultSet` 을 객체로 변환한다.

### RowMapper
* 데이터베이스의 조회 결과를 객체로 변환할 때 사용한다.
* JDBC를 직접 사용할 때 `ResultSet` 를 사용했던 부분을 떠올리면 된다.
* 차이가 있다면 다음과 같이 JdbcTemplate이 루프를 돌려주고, 개발자는 `RowMapper` 를 구현해서 그 내부 코드만 채운다고 이해하면 된다.

## 동적 쿼리 문제
* 결과를 검색하는 `findAll()` 에서 어려운 부분은 사용자가 검색하는 값에 따라서 실행하는 SQL이 동적으로 달려져야 한다는 점이다.
* 상품명(itemName)과 최대 가격(maxPrice) 을 고려해 검색할 경우, 사용 여부에 따라 4가지 경우가 생긴다.
```sql
select id, item_name, price, quantity from item
	where item_name like concat('%',?,'%')
	and price <= ?
```
* 실무에서는 이보다 훨씬 더 복잡한 동적 쿼리들이 사용된다.
* 참고로 이후에 설명할 MyBatis의 가장 큰 장점은 SQL을 직접 사용할 때 동적 쿼리를 쉽게 작성할 수 있다는 점이다.
