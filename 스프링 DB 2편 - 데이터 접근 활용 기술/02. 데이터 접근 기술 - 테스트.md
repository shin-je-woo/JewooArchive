# Previous
* 실제 데이터베이스를 연동해서 테스트를 하면 데이터베이스에 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문에 이 데이터가 테스트에 영향을 준다.
* 이런 문제를 해결하려면 테스트를 다른 환경과 철저하게 분리해야 한다.
* 가장 간단한 방법은 테스트 전용 데이터베이스를 별도로 운영하는 것이다. 그러나, 테스트를 위해 별도의 DB를 구비하는 것은 효율이 좋지 않다.
* 또한, 테스트를 2번 이상 실행하면 이전 테스트에서 저장된 데이터가 계속 남아있는 문제가 있을 수 있다.
* 아래 테스트의 중요한 원칙 2가지를 스프링은 어떻게 해결했는지 확인해보자.

> 테스트는 다른 테스트와 격리해야 한다.  
> 테스트는 반복해서 실행할 수 있어야 한다.

# 💡 테스트 - 데이터 롤백
트랜잭션을 활용하면 테스트가 끝나고 데이터를 깔끔하게 원래 상태로 되돌릴 수 있다.

## 트랜잭션 직접 적용
* `@BeforeEach` 에서 트랜잭션을 시작하고, `@AfterEach` 에서 트랜잭션을 롤백하는 코드를 작성해보자.

▶️ 테스트에 직접 트랜잭션 추가
```java
@SpringBootTest
class ItemRepositoryTest {

    @Autowired
    ItemRepository itemRepository;
    
    //트랜잭션 관련 코드
    @Autowired
    PlatformTransactionManager transactionManager;
    TransactionStatus status;

    @BeforeEach
    void beforeEach() {
        //트랜잭션 시작
        status = transactionManager.getTransaction(new DefaultTransactionDefinition());
    }

    @AfterEach
    void afterEach() {
        //MemoryItemRepository 의 경우 제한적으로 사용
        if (itemRepository instanceof MemoryItemRepository) {
            ((MemoryItemRepository) itemRepository).clearStore();
        }
        //트랜잭션 롤백
        transactionManager.rollback(status);
    }
    //...
}
```

## @Transactional
* 스프링은 테스트 데이터 초기화를 위해 트랜잭션을 적용하고 롤백하는 방식을 `@Transactional` 애노테이션 하나로 깔끔하게 해결해준다.
* 트랜잭션을 적용하려고 하는 테스트 클래스 또는 메서드에 `@Transactional` 을 붙이면 테스트 이후 자동으로 롤백해준다.
```java
@Transactional
@SpringBootTest
class ItemRepositoryTest { ... }
```

## 강제로 커밋하기 - @Commit
* `@Transactional` 을 테스트에서 사용하면 테스트가 끝나면 바로 롤백되기 때문에 테스트 과정에서 저장한 모든 데이터가 사라진다.
* 가끔은 데이터베이스에 데이터가 잘 보관되었는지 최종 결과를 눈으로 확인하고 싶을 때도 있다.
* 이럴 때 `@Commit` 이나 `@Rollback(value = false)` 를 붙여주면 롤백하지 않고 커밋한다.
```java
//@Rollback(value = false)
@Commit
@Transactional
@SpringBootTest
class ItemRepositoryTest { ... }
```

# 💡 테스트 - 임베디드 모드 DB
테스트 케이스를 실행하기 위해서 별도의 데이터베이스를 설치하고, 운영하는 것은 상당히 번잡한 작업이다.

## 임베디드 모드
* H2 데이터베이스는 자바로 개발되어 있고, JVM안에서 메모리 모드로 동작하는 특별한 기능을 제공한다.
* 그래서 애플리케이션을 실행할 때 H2 데이터베이스도 JVM 메모리에 포함해서 함께 실행할 수 있다. 
* DB를 애플리케이션에 내장해서 함께 실행한다고 해서 임베디드 모드(Embedded mode)라 한다.

## 임베디드 모드 직접 사용
```java
@Import(JdbcTemplateV3Config.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {

    public static void main(String[] args) {
      SpringApplication.run(ItemServiceApplication.class, args);
    }

    @Bean
    @Profile("test")
    public DataSource dataSource() {
      log.info("메모리 데이터베이스 초기화");
      DriverManagerDataSource dataSource = new DriverManagerDataSource();
      dataSource.setDriverClassName("org.h2.Driver");
      dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
      dataSource.setUsername("sa");
      dataSource.setPassword("");
      return dataSource;
    }
}
```
* `jdbc:h2:mem` : 이 부분이 중요하다. 데이터소스를 만들때 이렇게만 적으면 임베디드 모드(메모리 모드)로 동작하는 H2 데이터베이스를 사용할 수 있다.
* `DB_CLOSE_DELAY=-1` : 임베디드 모드에서는 데이터베이스 커넥션 연결이 모두 끊어지면 데이터베이스도 종료되는데, 그것을 방지하는 설정이다.
* 그런데, 이 설정으로 막상 실행해보면 **메모리 DB에는 아직 테이블을 만들지 않아** 오류가 발생한다.
* 테스트를 실행하기 전에 테이블을 먼저 생성해주어야 한다. 수동으로 할 수도 있지만 스프링 부트는 이 문제를 해결할 아주 편리한 기능을 제공해준다.

## 스프링 부트 - 기본 SQL 스크립트를 사용해서 데이터베이스를 초기화하는 기능
* 메모리 DB는 애플리케이션이 종료될 때 함께 사라지기 때문에, 애플리케이션 실행 시점에 데이터베이스 테이블도 새로 만들어주어야 한다.
* JDBC나 JdbcTemplate를 직접 사용해서 테이블을 생성하는 DDL을 호출해도 되지만, 너무 불편하다. 
* 스프링 부트는 SQL 스크립트를 실행해서 애플리케이션 로딩 시점에 데이터베이스를 초기화하는 기능을 제공한다.
* 다음 파일을 `src/test/resources/schema.sql` 에 생성하면 된다. 파일이름과 위치가 맞아야한다.

▶️ src/test/resources/schema.sql
```sql
drop table if exists item CASCADE;
create table item
(
    id        bigint generated by default as identity,
    item_name varchar(10),
    price     integer,
    quantity  integer,
    primary key (id)
);
```

## 스프링 부트와 임베디드 모드
* 스프링 부트는 임베디드 데이터베이스에 대한 설정도 기본으로 제공한다.
* 스프링 부트는 데이터베이스에 대한 별다른 설정이 없으면 임베디드 데이터베이스를 사용한다.
* 메모리 DB용 데이터소스 설정과 `src/test/resources/application.properties` 에서 DB관련 설정을 지우자.
* 이렇게 별다른 정보가 없으면 스프링 부트는 임베디드 모드로 접근하는 데이터소스( `DataSource` )를 만들어서 제공한다.
* 로그를 보면 `url=jdbc:h2:mem` 메모리용 DB가 만들어진 것을 확인할 수 있다.
```log
conn0: url=jdbc:h2:mem:d8fb3a29-caf7-4b37-9b6c-b0eed9985454
```
