# Previous
* 주문내역에서 추가로 주문한 상품 정보를 추가로 조회하자.
* Order기준으로 컬렉션인 OrderItem 와 Item 이 필요하다.
* 앞의 예제에서는 xxxToOne(OneToOne, ManyToOne) 관계만 있었다. 이번에는 컬렉션인 일대다 관계(OneToMany)를 조회하고, 최적화하는 방법을 알아보자.

# 💡 주문 조회 V1: 엔티티 직접 노출
```java
@GetMapping("/api/v1/orders")
List<Order> ordersV1() {
    List<Order> all = orderRepository.findAllByString(new OrderSearch());
    for (Order order : all) {
        order.getMember().getName(); //Lazy때문에 프록시객체 강제 초기화
        order.getDelivery().getStatus(); //Lazy때문에 프록시객체 강제 초기화

        List<OrderItem> orderItems = order.getOrderItems();
        orderItems.stream().forEach(o -> o.getItem().getName()); //Lazy때문에 프록시객체 강제 초기화(OrderItem, Item 둘 동시에)
    }
    return all;
}
```
* orderItem, item 관계를 직접 초기화하면 Hibernate5Module 설정에 의해 엔티티를 JSON으로 생성한다.
* 양방향 연관관계면 무한 루프에 걸리지 않게 한 곳에 @JsonIgnore 를 추가해야 한다.
* 엔티티를 직접 노출하므로 좋은 방법은 아니다.

# 💡 주문 조회 V2: 엔티티를 DTO로 변환
```java
@GetMapping("/api/v2/orders")
public List<OrderDto> ordersV2() {
    List<Order> orders = orderRepository.findAllByString(new OrderSearch());
    List<OrderDto> collect = orders.stream()
            .map(o -> new OrderDto(o))
            .collect(Collectors.toList());
    return collect;
}

@Data
static class OrderDto {
    private Long orderId;
    private String name;
    private LocalDateTime orderDate;
    private OrderStatus orderStatus;
    private Address address;
    private List<OrderItemDto> orderItems;

    public OrderDto(Order o) {
        orderId = o.getId();
        name = o.getMember().getName(); // Lazy 프록시 초기화
        orderDate = o.getOrderDate();
        orderStatus = o.getStatus();
        address = o.getDelivery().getAddress(); // Lazy 프록시 초기화
        orderItems = o.getOrderItems().stream()
                .map(orderItem -> new OrderItemDto(orderItem))
                .collect(Collectors.toList());
    }
}

@Data
static class OrderItemDto {
    private String itemName; //상품 명
    private int orderPrice; //주문 가격
    private int count; //주문 수량

    public OrderItemDto(OrderItem orderItem) {
        itemName = orderItem.getItem().getName(); // Lazy 프록시 초기화
        orderPrice = orderItem.getOrderPrice();
        count = orderItem.getCount();
    }
}
```
* OrderDto 생성자를 잘 살펴보면 OrderItems역시 지연로딩으로 호출해주고 있다. 하지만, OrderItem역시 엔티티이기 때문에 그대로 호출 해주면 안된다. 
* 그렇기 때문에 필요한 필드를 포함하는 OrderItemDto를 만들어서 생성해줘야 한다.
* 지연 로딩으로 너무 많은 SQL 실행
* SQL 실행 수
  * order리스트 1번
  * member, delivery N번(order 조회 수 만큼)
  * orderItem N번(order 조회 수 만큼)
  * item N번(orderItem 조회 수 만큼)

> 📌 참고  
> 지연 로딩은 영속성 컨텍스트에 있으면 영속성 컨텍스트에 있는 엔티티를 사용하고 없으면 SQL을 실행한다.    
> 따라서 같은 영속성 컨텍스트에서 이미 로딩한 회원 엔티티를 추가로 조회하면 SQL을 실행하지 않는다.

# 💡 주문 조회 V3: 엔티티를 DTO로 변환 - 페치 조인 최적화
```java
@GetMapping("/api/v3/orders")
List<OrderDto> ordersV3() {
    return orderRepository.findAllWithItem().stream()
            .map(o -> new OrderDto(o))
            .collect(toList());
}
```
```java
public List<Order> findAllWithItem() {
    return em.createQuery(
            "select distinct o from Order o " +
                    " join fetch o.member m" +
                    " join fetch o.delivery d" +
                    " join fetch o.orderItems oi" +
                    " join fetch oi.item i", Order.class
    ).getResultList();
}
```
* `페치 조인`으로 SQL이 1번만 실행됨
* `distinct` 를 사용한 이유는 1대다 조인이 있으므로 row수가 One의 갯수가 아닌 Many의 갯수만큼 증가한다.
*  그 결과 같은 order 엔티티의 조회 수도 증가하게 된다. JPA의 distinct는 SQL에 distinct를 추가하고, 더해서 같은 엔티티가 조회되면 애플리케이션에서 중복을 걸러준다.

✅ 컬렉션 페치조인과 페이징
* 컬렉션 페치 조인을 사용하면 페이징이 불가능하다.
* 하이버네이트는 경고 로그를 남기면서 `모든 데이터`를 DB에서 읽어오고, `메모리에서 페이징` 해버린다(매우 위험하다).
* 컬렉션 페치 조인은 1개만 사용할 수 있다. 
* 컬렉션 둘 이상 페치조인을 사용하면 데이터의 정합성이 떨어질 뿐만 아니라 N * N개로 조회되는 중복된 ROW의 수가 기하급수적으로 늘어나게 된다. 

# 💡 주문 조회 V3.1: 엔티티를 DTO로 변환 - 페이징과 한계 돌파
