# 💡 분해 패턴

- MSA 소프트웨어 아키텍처를 설계함에 있어서, 모놀리식 비즈니스 구조를 어떤 판단 기준에 따라 서비스를 분리할 것인지?
- 즉, "분해" 를 해결하기 위한 패턴

### 비즈니스 능력에 따른 분해 (Business Ability)

- 복잡한 "비즈니스 능력"을 기준으로 서비스를 분해
- e.g. 송금 서비스, 주문 서비스, ...

#### 장점

- 비즈니스가 복잡하고, 대규모 조직의 경우
- 비즈니스 특성으로 인해 내부 서비스간 통신이 매우 빈번할 경우

#### 단점

- 서비스 간 응집도, 결합도, 종속성 증가
- 서비스, 즉 도메인 별 팀의 구조가 희석될 가능성 (from Conway's Law)

### 하위 도메인 패턴별 분해 (Sub-Domain) from DDD
- 복잡한 비즈니스일지라도, 포함된 내부의 하위 도메인 단위로 분리
- e.g. 계좌 도메인, 내부 머니 도메인, 뱅킹(외부 은행과 통신만 담당)

#### 장점

- 서비스 간 독립성, 격리성이 증가 / 결합도 감소
- 서비스 간 종속성 최소화, 서비스 간 영향도 감소
- 장애 영향도 최소화
- MSA 철학에 부합하는 패턴

#### 단점

- 서비스 간 불필요한 통신 가능성. 성능 이슈
- 지나치게 많은 서비스로 분리될 가능성
- 대규모 시스템에서는 비효율성 크게 증가 가능성

![image](https://github.com/user-attachments/assets/85e7ad94-5b36-4783-bd73-0ffb323cb1dc)

# 💡 통신 패턴

- MSA 설계(즉, 분해)를 통해 도출된 서비스 간 어떤 방식으로 통신을 할 지 결정하는 패턴
- 즉, "통신"을 해결하기 위한 패턴

### Sync Pattern (동기 패턴)

- 어떤 서비스가 다른 서비스로 특정 Request 이후, 그 Response를 받을 때까지 멈춰있어도 되는 경우
- e.g. HTTP(Restful), gRPC

### Async Pattern (비동기 패턴)

- 어떤 서비스가 다른 서비스로 특정 Request 이후, 그 Response를 당장은 받지 않아도 되는 경우
- e.g. Kafka 등을 이용한 Message Queueing, Callback, Polling, ....

# 💡 트랜잭션 패턴

- MSA 설계를 통해 도출된 서비스를 사용하여 트랜잭션을 해결해 주기 위한 패턴
- 즉, "트랜잭션"을 해결하기 위한 패턴

### 2PC ( 2Phase Commit )

- "트랜잭션의 완료"를 2(N) 단계에 거쳐서 결정
- Commit Request -> 정말 commit 해도 되는지 확인 -> 성공시 commit, 실패시 rollback

![image](https://github.com/user-attachments/assets/02a686f9-6e99-47ce-bb2d-b71c3824d3e7)

- 위 그림에서 송금 서비스가 Cordinator로 commit 요청을 했지만, 계좌 확인 서비스에 문제가 발생해서 commit요청을 못 받을 경우 문제가 발생한다. (처리를 진행하지 못한다.)

### Compensating Transactions (보상 트랜잭션)

- 특정 요청과 그 요청에 대해 정상적이고 완전히 종료된 "행동"(트랜잭션)을 그 이전 상태로 되돌리기 위한 "행동"(트랜잭션)

![image](https://github.com/user-attachments/assets/79f0b77f-4493-46b9-b3e7-54abf2060000)

- 보상트랜잭션도 2PC와 마찬가지로 계좌 확인 서비스에 문제가 발생해서 보상 요청을 못보낼 경우 문제가 된다.
- 또, 만약 보상 요청을 했지만, 송금 서비스에 문제가 발생해서 보상 요청을 못받을 경우 또한 문제가 된다. 

### Saga Pattern (사가 패턴)

- 트랜잭션의 선, 후 관계를 사전에 정의하고 필요와 경우에 따라 Cordinator 가 보상 트랜잭션을 이용, 관리하여 분산 시스템 환경에서 트랜잭션을 구현하기 위한 패턴

![image](https://github.com/user-attachments/assets/8951e3fd-7705-43cc-826a-dace6bc36773)

# 💡 데이터 쿼리 패턴

### API Aggregation 패턴

- 필요한 데이터를 얻어오기 위해서, 분리된 서비스들 각각에 각 도메인에 대한 데이터를 요청 후 필요에 맞게 Aggregation
- e.g. 송금이 최종적으로 성공한 요청 건에 대해서, 같이 실행된 외부 은행에 대한 계좌 요청들의 외부 API 호출 횟수

### CQRS 패턴

- Command(Write, Update, Delete) 작업과, Query(Read) 작업의 Endpoint를 분리하고, Command에서 발생된 데이터의 변경을 이벤트 발행을 통해 원하는 포맷대로 Query를 위한 전용 데이터 구조를 만들어 이곳에서 복잡한 Query를 담당.
- 수많은 API Aggregation을 단 한번의 쿼리로 조회할 수 있게 된다.
- e.g. 강남구에 사는 모든 주민들의 잔액 총합을 실시간으로 알고 싶다면?

# 💡 가시성 (Visibility, Observability)

- MSA 소프트웨어 아키텍처를 설계하면서 생긴 로깅, 모니터링의 어려움(가시성의 부재)을 해결하기 위한 패턴
- 로깅 및 메트릭의 중앙집중 및 필터링 등을 통한 한곳에서의 모니터링
- 하나의 트랜잭션에 대해 여러개의 각 서비스 요청들을 하나의 요청처럼 볼 수 있게 하는 트레이싱
- 로깅과 메트릭의 차이? 추구하는 가치가 다르므로, 적절한 목적에 맞게 사용
  - 로깅: 트러블슈팅을 위한 목적이 크다. 누락되면 안된다.
  - 메트릭: 서비스의 지표. 시계열로 저장. 시간에 따라 증감하는 수치를 본다. 일부 누락 되어도 괜찮다. (e.g. 최근 5분간 송금 상승률) Prometheus, influxDB
- "구체적으로 어떻게 로깅, 메트릭을 저장하고 인덱싱하여 검색할 지에 집중하는 패턴"

# 💡 신뢰성 (Reliability)

- MSA 소프트웨어 아키텍처를 설계하면서, 분리/분해로 인해 떨어진 신뢰성을 해결하기 위한 패턴
- 장애 복구, 자가 치유, 무정지 배포 등을 구현하기 위한 패턴들이 이에 속한다.

### 서킷 브레이커 (Circuit Breaker)

- 신뢰성을 높이기 위한 패턴의 일종으로, 분산 시스템에서 장애 전파를 막고 피해를 최소화 하기 위한 패턴

# 💡 테스트 패턴, 외부 API 패턴, 디스커버리 패턴

### 테스트 패턴

- 분리된 서비스들이 서로 빈번하게 호출되는 모놀리식과는 다른 환경 MSA 환경에서, 여러 테스트 방식을 적용하여 "테스트"의 본질적인 의미를 해결하기 위한 패턴
- e.g. 단위 테스트, 통합 테스트, E2E 테스트 (종단간 테스트)

### 외부 API 패턴

- 서비스 간의 통신 시 구현과 관련된 종속성을 해결하기 위한 패턴.
- 어떤 서비스가 다른 특정 서비스를 호출할 때, 직접 호출하는 것이 아닌 리버스 프록시 역할을 하는 인터페이스
- 서비스를 제공하여 마이크로서비스 간 내부 구현방식과 무관하게 유연성을 가질 수 있는 패턴
- 즉, 서비스 호출 시에는 "필요한 데이터" 만, 실제 구현은 상황에 따라 유연하게.

### 디스커버리 패턴

- 수 많은 컨테이너, 서버들의 상태를 정상적으로 관리하기 어려웠던 문제를 해결하기 위한 패턴.
- 수 많은 서비스들이 정상적으로 동작하는지를 판단하고, 상황에 따라 적절한 동작을 하는 메커니즘을 제공하는 패턴
- e.g. 쿠버네티스의 Rediness Probe, Liveness Probe
